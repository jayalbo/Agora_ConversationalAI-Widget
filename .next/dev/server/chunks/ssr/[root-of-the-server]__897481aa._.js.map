{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///Users/jalbo/Desktop/dev/blog/convoAI_ecommerce/components/ProductImages.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState } from 'react';\n\ninterface ProductImagesProps {\n  images: string[];\n}\n\nexport function ProductImages({ images }: ProductImagesProps) {\n  const [selectedImage, setSelectedImage] = useState(0);\n\n  return (\n    <div className=\"bg-white rounded-lg shadow-sm p-6\">\n      <img\n        src={images[selectedImage]}\n        alt=\"Product\"\n        className=\"w-full h-96 object-contain mb-4 rounded-lg\"\n      />\n      <div className=\"flex gap-2 overflow-x-auto\">\n        {images.map((img, idx) => (\n          <img\n            key={idx}\n            src={img}\n            alt={`Product view ${idx + 1}`}\n            onClick={() => setSelectedImage(idx)}\n            className={`w-20 h-20 object-cover rounded cursor-pointer border-2 transition ${\n              selectedImage === idx \n                ? 'border-blue-600 ring-2 ring-blue-200' \n                : 'border-gray-200 hover:border-gray-300'\n            }`}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n\n"],"names":[],"mappings":";;;;;AAEA;AAFA;;;AAQO,SAAS,cAAc,EAAE,MAAM,EAAsB;IAC1D,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,iNAAQ,EAAC;IAEnD,qBACE,8OAAC;QAAI,WAAU;;0BACb,8OAAC;gBACC,KAAK,MAAM,CAAC,cAAc;gBAC1B,KAAI;gBACJ,WAAU;;;;;;0BAEZ,8OAAC;gBAAI,WAAU;0BACZ,OAAO,GAAG,CAAC,CAAC,KAAK,oBAChB,8OAAC;wBAEC,KAAK;wBACL,KAAK,CAAC,aAAa,EAAE,MAAM,GAAG;wBAC9B,SAAS,IAAM,iBAAiB;wBAChC,WAAW,CAAC,kEAAkE,EAC5E,kBAAkB,MACd,yCACA,yCACJ;uBARG;;;;;;;;;;;;;;;;AAcjB"}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///Users/jalbo/Desktop/dev/blog/convoAI_ecommerce/components/ProductReviews.tsx"],"sourcesContent":["\"use client\";\n\ninterface Review {\n  id: number;\n  userName: string;\n  rating: number;\n  date: string;\n  title: string;\n  comment: string;\n  verified: boolean;\n}\n\ninterface ProductReviewsProps {\n  reviews: Review[];\n  rating: number;\n}\n\nexport function ProductReviews({ reviews, rating }: ProductReviewsProps) {\n  return (\n    <div className=\"bg-white rounded-lg shadow-sm p-6 mt-8\">\n      <div className=\"flex items-center justify-between mb-6\">\n        <h2 className=\"text-2xl font-semibold\">Customer Reviews</h2>\n        <div className=\"text-right\">\n          <div className=\"text-3xl font-bold text-gray-900\">{rating}</div>\n          <div className=\"text-sm text-gray-600\">out of 5</div>\n        </div>\n      </div>\n      <div className=\"space-y-6\">\n        {reviews.map((review) => (\n          <div key={review.id} className=\"border-b pb-6 last:border-b-0\">\n            <div className=\"flex items-start justify-between mb-2\">\n              <div className=\"flex-1\">\n                <div className=\"flex items-center gap-2 mb-1\">\n                  <span className=\"font-semibold text-gray-900\">{review.userName}</span>\n                  {review.verified && (\n                    <span className=\"text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded\">\n                      Verified Purchase\n                    </span>\n                  )}\n                </div>\n                <div className=\"flex items-center gap-2 mt-1\">\n                  <span className=\"text-yellow-400\">\n                    {'★'.repeat(review.rating)}\n                    {'☆'.repeat(5 - review.rating)}\n                  </span>\n                  <span className=\"text-sm text-gray-500\">{review.date}</span>\n                </div>\n              </div>\n            </div>\n            <h4 className=\"font-medium mt-2 text-gray-900\">{review.title}</h4>\n            <p className=\"text-gray-700 mt-1 leading-relaxed\">{review.comment}</p>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\n"],"names":[],"mappings":";;;;;AAAA;;AAiBO,SAAS,eAAe,EAAE,OAAO,EAAE,MAAM,EAAuB;IACrE,qBACE,8OAAC;QAAI,WAAU;;0BACb,8OAAC;gBAAI,WAAU;;kCACb,8OAAC;wBAAG,WAAU;kCAAyB;;;;;;kCACvC,8OAAC;wBAAI,WAAU;;0CACb,8OAAC;gCAAI,WAAU;0CAAoC;;;;;;0CACnD,8OAAC;gCAAI,WAAU;0CAAwB;;;;;;;;;;;;;;;;;;0BAG3C,8OAAC;gBAAI,WAAU;0BACZ,QAAQ,GAAG,CAAC,CAAC,uBACZ,8OAAC;wBAAoB,WAAU;;0CAC7B,8OAAC;gCAAI,WAAU;0CACb,cAAA,8OAAC;oCAAI,WAAU;;sDACb,8OAAC;4CAAI,WAAU;;8DACb,8OAAC;oDAAK,WAAU;8DAA+B,OAAO,QAAQ;;;;;;gDAC7D,OAAO,QAAQ,kBACd,8OAAC;oDAAK,WAAU;8DAAsD;;;;;;;;;;;;sDAK1E,8OAAC;4CAAI,WAAU;;8DACb,8OAAC;oDAAK,WAAU;;wDACb,IAAI,MAAM,CAAC,OAAO,MAAM;wDACxB,IAAI,MAAM,CAAC,IAAI,OAAO,MAAM;;;;;;;8DAE/B,8OAAC;oDAAK,WAAU;8DAAyB,OAAO,IAAI;;;;;;;;;;;;;;;;;;;;;;;0CAI1D,8OAAC;gCAAG,WAAU;0CAAkC,OAAO,KAAK;;;;;;0CAC5D,8OAAC;gCAAE,WAAU;0CAAsC,OAAO,OAAO;;;;;;;uBArBzD,OAAO,EAAE;;;;;;;;;;;;;;;;AA2B7B"}},
    {"offset": {"line": 226, "column": 0}, "map": {"version":3,"sources":["file:///Users/jalbo/Desktop/dev/blog/convoAI_ecommerce/hooks/useAgora.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect, useRef } from \"react\";\n\ninterface UseAgoraProps {\n  appId: string;\n  channel: string;\n  token: string;\n  uid: number;\n}\n\nexport function useAgora({ appId, channel, token, uid }: UseAgoraProps) {\n  const [isConnected, setIsConnected] = useState(false);\n  const [isMuted, setIsMuted] = useState(false); // Microphone enabled by default (not muted)\n  const [localAudioTrack, setLocalAudioTrack] = useState<any>(null);\n  const [remoteAudioTrack, setRemoteAudioTrack] = useState<any>(null);\n  const clientRef = useRef<any>(null);\n\n  useEffect(() => {\n    // Don't initialize if we don't have valid config or if we're on the server\n    if (\n      typeof window === \"undefined\" ||\n      !appId ||\n      !channel ||\n      !token ||\n      uid === 0 ||\n      !appId.trim() ||\n      !channel.trim() ||\n      !token.trim()\n    ) {\n      return;\n    }\n\n    let isMounted = true;\n    let audioTrack: any = null;\n    let client: any = null;\n\n    const init = async () => {\n      try {\n        // Dynamically import AgoraRTC only on the client\n        const AgoraRTC = (await import(\"agora-rtc-sdk-ng\")).default;\n        // Enable audio PTS metadata for Conversational AI (required)\n        (AgoraRTC as any).setParameter(\"ENABLE_AUDIO_PTS_METADATA\", true);\n        client = AgoraRTC.createClient({ mode: \"rtc\", codec: \"vp8\" });\n        clientRef.current = client;\n\n        // Join the channel\n        await client.join(appId, channel, token, uid);\n\n        if (!isMounted) {\n          // Component unmounted during join, cleanup\n          await client.leave().catch(() => {});\n          return;\n        }\n\n        setIsConnected(true);\n\n        // Create and publish local audio track\n        audioTrack = await AgoraRTC.createMicrophoneAudioTrack();\n\n        if (!isMounted) {\n          // Component unmounted during track creation, cleanup\n          audioTrack.close();\n          await client.leave().catch(() => {});\n          return;\n        }\n\n        await client.publish([audioTrack]);\n        setLocalAudioTrack(audioTrack);\n\n        // Listen for remote audio tracks\n        client.on(\"user-published\", async (user: any, mediaType: string) => {\n          if (mediaType === \"audio\" && isMounted) {\n            try {\n              await client!.subscribe(user, mediaType);\n              const remoteTrack = user.audioTrack;\n              if (remoteTrack && isMounted) {\n                setRemoteAudioTrack(remoteTrack);\n                remoteTrack.play();\n              }\n            } catch (error) {\n              console.error(\"Error subscribing to remote audio:\", error);\n            }\n          }\n        });\n\n        client.on(\"user-unpublished\", (user: any, mediaType: string) => {\n          if (mediaType === \"audio\" && isMounted) {\n            setRemoteAudioTrack(null);\n          }\n        });\n      } catch (error: any) {\n        // Ignore OPERATION_ABORTED errors (happens when component unmounts during init)\n        if (error?.code !== \"OPERATION_ABORTED\" && isMounted) {\n          console.error(\"Agora initialization error:\", error);\n        }\n        if (isMounted) {\n          setIsConnected(false);\n        }\n      }\n    };\n\n    init();\n\n    return () => {\n      isMounted = false;\n\n      // Cleanup\n      if (audioTrack) {\n        audioTrack.close();\n        audioTrack = null;\n      }\n\n      if (clientRef.current) {\n        const currentClient = clientRef.current;\n        clientRef.current = null;\n        currentClient.leave().catch(() => {\n          // Ignore errors during cleanup\n        });\n      }\n\n      setIsConnected(false);\n      setLocalAudioTrack(null);\n      setRemoteAudioTrack(null);\n    };\n  }, [appId, channel, token, uid]);\n\n  const toggleMute = async () => {\n    if (localAudioTrack) {\n      await localAudioTrack.setMuted(!isMuted);\n      setIsMuted(!isMuted);\n    }\n  };\n\n  const leave = async () => {\n    if (localAudioTrack) {\n      localAudioTrack.close();\n      setLocalAudioTrack(null);\n    }\n    if (clientRef.current) {\n      await clientRef.current.leave();\n      setIsConnected(false);\n    }\n  };\n\n  return {\n    isConnected,\n    isMuted,\n    toggleMute,\n    leave,\n    localAudioTrack,\n    remoteAudioTrack,\n    client: clientRef.current,\n  };\n}\n"],"names":[],"mappings":";;;;AAEA;AAFA;;AAWO,SAAS,SAAS,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,EAAiB;IACpE,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,iNAAQ,EAAC;IAC/C,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,iNAAQ,EAAC,QAAQ,4CAA4C;IAC3F,MAAM,CAAC,iBAAiB,mBAAmB,GAAG,IAAA,iNAAQ,EAAM;IAC5D,MAAM,CAAC,kBAAkB,oBAAoB,GAAG,IAAA,iNAAQ,EAAM;IAC9D,MAAM,YAAY,IAAA,+MAAM,EAAM;IAE9B,IAAA,kNAAS,EAAC;QACR,2EAA2E;QAC3E,IACE,kDAAkB,eAClB,CAAC,SACD,CAAC,WACD,CAAC,SACD,QAAQ,KACR,CAAC,MAAM,IAAI,MACX,CAAC,QAAQ,IAAI,MACb,CAAC,MAAM,IAAI,IACX;YACA;QACF;;;QAEA,IAAI;QACJ,IAAI;QACJ,IAAI;QAEJ,MAAM;IAwFR,GAAG;QAAC;QAAO;QAAS;QAAO;KAAI;IAE/B,MAAM,aAAa;QACjB,IAAI,iBAAiB;YACnB,MAAM,gBAAgB,QAAQ,CAAC,CAAC;YAChC,WAAW,CAAC;QACd;IACF;IAEA,MAAM,QAAQ;QACZ,IAAI,iBAAiB;YACnB,gBAAgB,KAAK;YACrB,mBAAmB;QACrB;QACA,IAAI,UAAU,OAAO,EAAE;YACrB,MAAM,UAAU,OAAO,CAAC,KAAK;YAC7B,eAAe;QACjB;IACF;IAEA,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA,QAAQ,UAAU,OAAO;IAC3B;AACF"}},
    {"offset": {"line": 364, "column": 0}, "map": {"version":3,"sources":["file:///Users/jalbo/Desktop/dev/blog/convoAI_ecommerce/lib/conversational-ai-api/type.ts"],"sourcesContent":["import type {\n  ConnectionDisconnectedReason,\n  ConnectionState,\n  IAgoraRTCRemoteUser,\n  ICameraVideoTrack,\n  IMicrophoneAudioTrack,\n  NetworkQuality,\n  UID\n} from 'agora-rtc-sdk-ng'\nimport type { RTMEvents } from 'agora-rtm'\n\n/**\n * Transcript modes for the Conversational AI API\n *\n * @description\n * Defines the different modes available for transcript processing and display.\n * Used to determine how transcription data should be handled and presented.\n *\n * @remarks\n * - All modes are string literals for easy serialization\n * - Modes determine the granularity of transcript processing\n * - TEXT should be used as a fallback for unrecognized modes\n *\n * Values include:\n * - TEXT: Plain text mode for simple transcript display\n * - WORD: Word-level processing with individual word tracking\n * - CHUNK: Chunk-based processing for grouped text segments\n * - UNKNOWN: Initial mode for unrecognized transcript types\n *\n * @since 1.6.0\n */\nexport enum ETranscriptHelperMode {\n  TEXT = 'text',\n  WORD = 'word',\n  CHUNK = 'chunk',\n  UNKNOWN = 'unknown'\n}\n\nexport enum EMessageType {\n  USER_TRANSCRIPTION = 'user.transcription',\n  AGENT_TRANSCRIPTION = 'assistant.transcription',\n  MSG_INTERRUPTED = 'message.interrupt',\n  MSG_METRICS = 'message.metrics',\n  MSG_ERROR = 'message.error',\n  /** @deprecated */\n  MSG_STATE = 'message.state',\n  IMAGE_UPLOAD = 'image.upload',\n  MESSAGE_INFO = 'message.info',\n  MESSAGE_SAL_STATUS = 'message.sal_status'\n}\n\nexport enum ERTMEvents {\n  MESSAGE = 'message',\n  PRESENCE = 'presence',\n  // TOPIC = 'topic',\n  // STORAGE = 'storage',\n  // LOCK = 'lock',\n  STATUS = 'status'\n  // LINK_STATE = 'linkState',\n  // TOKEN_PRIVILEGE_WILL_EXPIRE = 'tokenPrivilegeWillExpire',\n}\n\nexport enum ERTCEvents {\n  NETWORK_QUALITY = 'network-quality',\n  USER_PUBLISHED = 'user-published',\n  USER_UNPUBLISHED = 'user-unpublished',\n  STREAM_MESSAGE = 'stream-message',\n  USER_JOINED = 'user-joined',\n  USER_LEFT = 'user-left',\n  CONNECTION_STATE_CHANGE = 'connection-state-change',\n  // AUDIO_METADATA = 'audio-metadata',\n  AUDIO_PTS = 'audio-pts'\n}\n\nexport enum ERTCCustomEvents {\n  MICROPHONE_CHANGED = 'microphone-changed',\n  REMOTE_USER_CHANGED = 'remote-user-changed',\n  REMOTE_USER_JOINED = 'remote-user-joined',\n  REMOTE_USER_LEFT = 'remote-user-left',\n  LOCAL_TRACKS_CHANGED = 'local-tracks-changed'\n}\n\n/**\n * Event types for the Conversational AI API\n *\n * @description\n * Defines the event types that can be emitted by the Conversational AI API.\n * Contains events for agent state changes, interruptions, metrics, errors, transcription updates, debug logs, and message receipt updates.\n *\n * @remarks\n * - All events are string literals and can be used with event listeners\n * - Events are case-sensitive\n *\n * Values include:\n * - AGENT_STATE_CHANGED: Agent state change events\n * - AGENT_INTERRUPTED: Agent interruption events\n * - AGENT_METRICS: Agent performance metrics\n * - AGENT_ERROR: Agent error events\n * - TRANSCRIPT_UPDATED: Transcription update events\n * - DEBUG_LOG: Debug logging events\n * - MESSAGE_RECEIPT_UPDATED: Message receipt update events\n * - MESSAGE_ERROR: Message error events\n *\n * @since 1.6.0\n */\nexport enum EConversationalAIAPIEvents {\n  AGENT_STATE_CHANGED = 'agent-state-changed',\n  AGENT_INTERRUPTED = 'agent-interrupted',\n  AGENT_METRICS = 'agent-metrics',\n  AGENT_ERROR = 'agent-error',\n  TRANSCRIPT_UPDATED = 'transcript-updated',\n  DEBUG_LOG = 'debug-log',\n  MESSAGE_RECEIPT_UPDATED = 'message-receipt-updated',\n  MESSAGE_ERROR = 'message-error',\n  MESSAGE_SAL_STATUS = 'message-sal-status'\n}\n\n/**\n * Module type enumeration for AI capabilities\n *\n * Defines the different types of AI modules available in the system, including language models and text-to-speech\n *\n * @remarks\n * - Each enum value represents a distinct AI capability module\n * - Use these values to specify module type in API calls\n *\n * Values include:\n * - LLM: Language Learning Model\n * - MLLM: Multimodal Language Learning Model\n * - TTS: Text-to-Speech\n * - CONTEXT: Context management module\n * - UNKNOWN: Unknown module type\n *\n * @since 1.6.0\n */\nexport enum EModuleType {\n  LLM = 'llm',\n  MLLM = 'mllm',\n  TTS = 'tts',\n  CONTEXT = 'context',\n  UNKNOWN = 'unknown'\n}\n\n/**\n * Agent metrics statistics data type definition\n *\n * @description\n * Used to store metric data during AI agent runtime, including type, name, value and timestamp\n *\n * @param type - Metric module type {@link EModuleType}\n * @param name - Metric name\n * @param value - Metric value\n * @param timestamp - Data collection timestamp (milliseconds)\n *\n * @since 1.6.0\n */\nexport type TAgentMetric = {\n  type: EModuleType\n  name: string\n  value: number\n  timestamp: number\n}\n\n/**\n * Message receipt type definition\n *\n * @description\n * Represents a message receipt from the AI module, including type, message content and turn ID\n *\n * @param moduleType - The module type that sent the message {@link EModuleType}\n * @param messageType - The type of the message {@link EChatMessageType}\n * @param message - The content of the message\n * @param turnId - Unique identifier for the conversation turn\n *\n * @since 1.7.0\n */\nexport type TMessageReceipt = {\n  moduleType: EModuleType\n  messageType: EChatMessageType\n  message: string\n  turnId: number\n}\n\n/**\n * Module error type definition\n *\n * @description\n * Represents error information from different AI modules including error type, code,\n * message and timestamp. Used for error handling and debugging.\n *\n * @remarks\n * - Error codes are module-specific and should be documented by each module\n * - Timestamp is in Unix milliseconds format\n * - Error messages should be human readable and provide actionable information\n *\n * @param type - The module type where error occurred {@link EModuleType}\n * @param code - Error code specific to the module\n * @param message - Human readable error description\n * @param timestamp - Unix timestamp in milliseconds when error occurred\n *\n * @since 1.6.0\n */\nexport type TModuleError = {\n  type: EModuleType\n  code: number\n  message: string\n  timestamp: number\n}\n\n/**\n * Type definition for state change event\n *\n * Used to describe the information related to voice agent state changes, including current state, turn ID, timestamp and reason\n *\n * @param state Current state of the voice agent. See {@link EAgentState}\n * @param turnID Unique identifier for the current conversation turn\n * @param timestamp Timestamp when the state change occurred (in milliseconds)\n * @param reason Reason description for the state change\n *\n * @since 1.6.0\n *\n * @remarks\n * - State change events are triggered when the voice agent's state changes\n * - timestamp uses UNIX timestamp (in milliseconds)\n */\nexport type TStateChangeEvent = {\n  state: EAgentState\n  turnID: number\n  timestamp: number\n  reason: string\n}\n\n/**\n * Event handlers interface for the Conversational AI API module.\n *\n * @since 1.6.0\n *\n * Defines a set of event handlers that can be implemented to respond to various\n * events emitted by the Conversational AI system, including agent state changes,\n * interruptions, metrics, errors, and transcription updates.\n *\n * @remarks\n * - All handlers are required to be implemented when using this interface\n * - Events are emitted asynchronously and should be handled accordingly\n * - Event handlers should be lightweight to avoid blocking the event loop\n * - Error handling should be implemented within each handler to prevent crashes\n *\n * @example\n * ```typescript\n * const handlers: IConversationalAIAPIEventHandlers = {\n *   [EConversationalAIAPIEvents.AGENT_STATE_CHANGED]: (agentUserId, event) => {\n *     console.log(`Agent ${agentUserId} state changed:`, event);\n *   },\n *   // ... implement other handlers\n * };\n * ```\n *\n * @param agentUserId - The unique identifier of the AI agent\n * @param event - Event data specific to each event type\n * @param metrics - Performance metrics data for the agent\n * @param error - Error information when agent encounters issues\n * @param transcription - Array of transcription items containing user and agent dialogue\n * @param message - Debug log message string\n * @param messageReceipt - Updated message receipt information\n * @param messageError - Error information related to a specific message\n *\n * @see {@link EConversationalAIAPIEvents} for all available event types\n * @see {@link TStateChangeEvent} for state change event structure\n * @see {@link TAgentMetric} for agent metrics structure\n * @see {@link TModuleError} for error structure\n * @see {@link ITranscriptHelperItem} for transcription item structure\n * @see {@link TMessageReceipt} for message receipt structure\n * @see {@link EChatMessageType} for message type enumeration\n */\nexport interface IConversationalAIAPIEventHandlers {\n  [EConversationalAIAPIEvents.AGENT_STATE_CHANGED]: (\n    agentUserId: string,\n    event: TStateChangeEvent\n  ) => void\n  [EConversationalAIAPIEvents.AGENT_INTERRUPTED]: (\n    agentUserId: string,\n    event: {\n      turnID: number\n      timestamp: number\n    }\n  ) => void\n  [EConversationalAIAPIEvents.AGENT_METRICS]: (\n    agentUserId: string,\n    metrics: TAgentMetric\n  ) => void\n  [EConversationalAIAPIEvents.AGENT_ERROR]: (\n    agentUserId: string,\n    error: TModuleError\n  ) => void\n  [EConversationalAIAPIEvents.TRANSCRIPT_UPDATED]: (\n    transcription: ITranscriptHelperItem<\n      Partial<IUserTranscription | IAgentTranscription>\n    >[]\n  ) => void\n  [EConversationalAIAPIEvents.DEBUG_LOG]: (message: string) => void\n  [EConversationalAIAPIEvents.MESSAGE_RECEIPT_UPDATED]: (\n    agentUserId: string,\n    messageReceipt: TMessageReceipt\n  ) => void\n  [EConversationalAIAPIEvents.MESSAGE_ERROR]: (\n    agentUserId: string,\n    error: {\n      type: EChatMessageType\n      code: number\n      message: string\n      timestamp: number\n    }\n  ) => void\n  [EConversationalAIAPIEvents.MESSAGE_SAL_STATUS]: (\n    agentUserId: string,\n    salStatus: IMessageSalStatus\n  ) => void\n}\n\n// export interface IHelperRTMEvents {\n//   [ERTMEvents.MESSAGE]: (message: RTMEvents.MessageEvent) => void\n//   [ERTMEvents.PRESENCE]: (message: RTMEvents.PresenceEvent) => void\n//   [ERTMEvents.STATUS]: (\n//     message: RTMEvents.RTMConnectionStatusChangeEvent\n//   ) => void\n// }\n\nexport interface IHelperRTCEvents {\n  [ERTCEvents.NETWORK_QUALITY]: (quality: NetworkQuality) => void\n  [ERTCEvents.USER_PUBLISHED]: (\n    user: IAgoraRTCRemoteUser,\n    mediaType: 'audio' | 'video'\n  ) => void\n  [ERTCEvents.USER_UNPUBLISHED]: (\n    user: IAgoraRTCRemoteUser,\n    mediaType: 'audio' | 'video'\n  ) => void\n  [ERTCEvents.USER_JOINED]: (user: IAgoraRTCRemoteUser) => void\n  [ERTCEvents.USER_LEFT]: (user: IAgoraRTCRemoteUser, reason?: string) => void\n  [ERTCEvents.CONNECTION_STATE_CHANGE]: (data: {\n    curState: ConnectionState\n    revState: ConnectionState\n    reason?: ConnectionDisconnectedReason\n    channel: string\n  }) => void\n  // [ERTCEvents.AUDIO_METADATA]: (metadata: Uint8Array) => void @deprecated\n  [ERTCEvents.AUDIO_PTS]: (pts: number) => void\n  [ERTCEvents.STREAM_MESSAGE]: (uid: UID, stream: Uint8Array) => void\n}\n\nexport class NotFoundError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'NotFoundError'\n  }\n}\n\n// --- Message ---\nexport type TDataChunkMessageWord = {\n  word: string\n  start_ms: number\n  duration_ms: number\n  stable: boolean\n}\n\nexport type TTranscriptHelperObjectWord = TDataChunkMessageWord & {\n  word_status?: ETurnStatus\n}\n\nexport enum ETurnStatus {\n  IN_PROGRESS = 0,\n  END = 1,\n  INTERRUPTED = 2\n}\n\n/**\n * Agent state enumeration\n *\n * Represents the different states of a conversational AI agent, including idle, listening, thinking, speaking and silent states\n *\n * Detailed Description:\n * This enum is used to track and manage the current state of an AI agent in a conversational system.\n * The states help coordinate the interaction flow between the user and the AI agent.\n *\n * States include:\n * - IDLE: Agent is ready for new interaction\n * - LISTENING: Agent is receiving user input\n * - THINKING: Agent is processing received input\n * - SPEAKING: Agent is delivering response\n * - SILENT: Agent is intentionally not responding\n *\n * @remarks\n * - State transitions should be handled properly to avoid deadlocks\n * - The SILENT state is different from IDLE as it represents an intentional non-response\n *\n * @since 1.6.0\n */\nexport enum EAgentState {\n  IDLE = 'idle',\n  LISTENING = 'listening',\n  THINKING = 'thinking',\n  SPEAKING = 'speaking',\n  SILENT = 'silent'\n}\n\nexport interface ITranscriptionBase {\n  object: EMessageType\n  text: string\n  start_ms: number\n  duration_ms: number\n  language: string\n  turn_id: number\n  stream_id: number\n  user_id: string\n  words: TDataChunkMessageWord[] | null\n}\n\nexport interface IUserTranscription extends ITranscriptionBase {\n  object: EMessageType.USER_TRANSCRIPTION // \"user.transcription\"\n  final: boolean\n}\n\nexport interface IAgentTranscription extends ITranscriptionBase {\n  object: EMessageType.AGENT_TRANSCRIPTION // \"assistant.transcription\"\n  quiet: boolean\n  turn_seq_id: number\n  turn_status: ETurnStatus\n}\n\nexport interface IMessageInterrupt {\n  object: EMessageType.MSG_INTERRUPTED // \"message.interrupt\"\n  message_id: string\n  data_type: 'message'\n  turn_id: number\n  start_ms: number\n  send_ts: number\n}\n\nexport interface IMessageMetrics {\n  object: EMessageType.MSG_METRICS // \"message.metrics\"\n  module: EModuleType\n  metric_name: string\n  turn_id: number\n  latency_ms: number\n  send_ts: number\n}\n\nexport interface IMessageError {\n  object: EMessageType.MSG_ERROR // \"message.error\"\n  module: EModuleType\n  code: number\n  message: string\n  turn_id: number\n  send_ts: number\n  [x: string]: unknown // Allow additional properties\n}\n\nexport interface IPresenceState\n  extends Omit<RTMEvents.PresenceEvent, 'stateChanged'> {\n  stateChanged: {\n    state: EAgentState\n    turn_id: string\n  }\n}\n\nexport type TQueueItem = {\n  turn_id: number\n  text: string\n  words: TTranscriptHelperObjectWord[]\n  status: ETurnStatus\n  stream_id: number\n  uid: string\n}\n\n/**\n * Interface for transcript helper item\n *\n * Defines the data structure for a single transcript item in the transcript system. Contains basic transcript information such as user ID, stream ID, turn ID, timestamp, text content, status, and metadata.\n *\n * @remarks\n * - This interface supports generics, allowing different types of metadata as needed\n * - Status value must be a valid value defined in {@link ETurnStatus}\n *\n * @param T - Type of metadata\n * @param uid - Unique identifier for the user\n * @param stream_id - Stream identifier\n * @param turn_id - Turn identifier in the conversation\n * @param _time - Timestamp of the transcript (in milliseconds)\n * @param text - Transcript text content\n * @param status - Current status of the transcript item\n * @param metadata - Additional metadata information\n *\n * @since 1.6.0\n */\nexport interface ITranscriptHelperItem<T> {\n  uid: string\n  stream_id: number\n  turn_id: number\n  _time: number\n  text: string\n  status: ETurnStatus\n  metadata: T | null\n}\n\n// --- rtc ---\nexport interface IUserTracks {\n  videoTrack?: ICameraVideoTrack\n  audioTrack?: IMicrophoneAudioTrack\n}\n\n// --- rtm ---\n\n/**\n * Enumeration defining chat message priority levels for handling message processing.\n *\n * Specifies how incoming chat messages should be handled when they arrive during\n * ongoing conversation processing, providing control over message queue behavior\n * and user experience during real-time interactions.\n *\n * @remarks\n * Values include:\n * - INTERRUPTED: Interrupt current processing and handle immediately\n * - APPEND: Add to processing queue for sequential handling\n * - IGNORE: Discard the message without processing\n *\n * @enum {string}\n *\n * @since 1.7.0\n */\nexport enum EChatMessagePriority {\n  INTERRUPTED = 'interrupted',\n  APPEND = 'append',\n  IGNORE = 'ignore'\n}\n\n/**\n * Enumeration defining the different types of chat messages supported in the conversational AI system.\n *\n * @remarks\n * Values include:\n * - TEXT: Text-based message\n * - IMAGE: Image-based message\n * - UNKNOWN: Unknown message type\n *\n * @enum {string}\n *\n * @since 1.7.0\n */\nexport enum EChatMessageType {\n  TEXT = 'text',\n  IMAGE = 'image',\n  UNKNOWN = 'unknown'\n}\n\n/**\n * Base interface for chat messages containing the fundamental message type property.\n * This interface serves as the foundation for all chat message types in the system.\n *\n * @since 1.7.0\n */\nexport interface IChatMessageBase {\n  messageType: EChatMessageType\n}\n\n/**\n * Represents a text-based chat message with priority and interruption settings.\n *\n * @interface IChatMessageText\n * @extends IChatMessageBase\n *\n * @property messageType - The type of message, must be TEXT\n * @property priority - The priority level of the chat message\n * @property responseInterruptable - Whether the response can be interrupted\n * @property text - The optional text content of the message\n *\n * @since 1.7.0\n */\nexport interface IChatMessageText extends IChatMessageBase {\n  messageType: EChatMessageType.TEXT\n  priority: EChatMessagePriority\n  responseInterruptable: boolean\n  text?: string\n}\n\n/**\n * Represents an image-based chat message that can contain either a URL or base64 encoded image data.\n *\n * @interface IChatMessageImage\n * @extends IChatMessageBase\n *\n * @property messageType - The type of message, must be IMAGE\n * @property uuid - Unique identifier for the image message\n * @property url - Optional URL pointing to the image resource\n * @property base64 - Optional base64 encoded image data\n */\nexport interface IChatMessageImage extends IChatMessageBase {\n  messageType: EChatMessageType.IMAGE\n  uuid: string\n  url?: string\n  base64?: string\n}\n\n// --- local ---\nexport enum ELocalTranscriptStatus {\n  PENDING = 'pending',\n  SENT = 'sent',\n  FAILED = 'failed'\n}\n\nexport interface ILocalTranscriptionBase {\n  id: string\n  uid: string\n  _time: number\n  status: ELocalTranscriptStatus\n}\n\nexport interface ILocalImageTranscription extends ILocalTranscriptionBase {\n  localImage: File\n  imageDimensions: {\n    width: number\n    height: number\n  }\n  image_url?: string\n}\n\nexport enum EMessageSalStatus {\n  VP_DISABLED = 'VP_DISABLED',\n  VP_UNREGISTER = 'VP_UNREGISTER',\n  VP_REGISTERING = 'VP_REGISTERING',\n  VP_REGISTER_SUCCESS = 'VP_REGISTER_SUCCESS',\n  VP_REGISTER_FAIL = 'VP_REGISTER_FAIL',\n  VP_REGISTER_DUPLICATE = 'VP_REGISTER_DUPLICATE'\n}\nexport interface IMessageSalStatus {\n  object: EMessageType.MESSAGE_SAL_STATUS // \"message.sal_status\"\n  status: EMessageSalStatus\n  timestamp: number\n  data_type: string\n  message_id: string\n  send_ts: number\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BO,IAAA,AAAK,+CAAA;;;;;WAAA;;AAOL,IAAA,AAAK,sCAAA;;;;;;IAMV,gBAAgB;;;;WANN;;AAaL,IAAA,AAAK,oCAAA;;;IAGV,mBAAmB;IACnB,uBAAuB;IACvB,iBAAiB;;WALP;;AAWL,IAAA,AAAK,oCAAA;;;;;;;;IAQV,qCAAqC;;WAR3B;;AAYL,IAAA,AAAK,0CAAA;;;;;;WAAA;;AA+BL,IAAA,AAAK,oDAAA;;;;;;;;;;WAAA;;AA8BL,IAAA,AAAK,qCAAA;;;;;;WAAA;;AAuNL,MAAM,sBAAsB;IACjC,YAAY,OAAe,CAAE;QAC3B,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAcO,IAAA,AAAK,qCAAA;;;;WAAA;;AA4BL,IAAA,AAAK,qCAAA;;;;;;WAAA;;AAoIL,IAAA,AAAK,8CAAA;;;;WAAA;;AAmBL,IAAA,AAAK,0CAAA;;;;WAAA;;AAuDL,IAAA,AAAK,gDAAA;;;;WAAA;;AAsBL,IAAA,AAAK,2CAAA;;;;;;;WAAA"}},
    {"offset": {"line": 513, "column": 0}, "map": {"version":3,"sources":["file:///Users/jalbo/Desktop/dev/blog/convoAI_ecommerce/lib/conversational-ai-api/utils/index.ts"],"sourcesContent":["// export const factoryFormatLog =\n//   (options: { tag: string }) => (message: unknown) => {\n//     return `[${options.tag}] ${JSON.stringify(message)}`\n//   }\nexport const factoryFormatLog =\n  (options: { tag: string }) =>\n  (...args: unknown[]) => {\n    return `[${options.tag}] ${args.map((arg) => JSON.stringify(arg)).join(' ')}`\n  }\n"],"names":[],"mappings":"AAAA,kCAAkC;AAClC,0DAA0D;AAC1D,2DAA2D;AAC3D,MAAM;;;;;AACC,MAAM,mBACX,CAAC,UACD,CAAC,GAAG;QACF,OAAO,CAAC,CAAC,EAAE,QAAQ,GAAG,CAAC,EAAE,EAAE,KAAK,GAAG,CAAC,CAAC,MAAQ,KAAK,SAAS,CAAC,MAAM,IAAI,CAAC,MAAM;IAC/E"}},
    {"offset": {"line": 528, "column": 0}, "map": {"version":3,"sources":["file:///Users/jalbo/Desktop/dev/blog/convoAI_ecommerce/lib/conversational-ai-api/utils/event.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\ntype EventHandler<T extends any[]> = (...data: T) => void\n\nexport class EventHelper<T> {\n  private _eventMap: Map<keyof T, EventHandler<any[]>[]> = new Map()\n\n  once<Key extends keyof T>(evt: Key, cb: T[Key]) {\n    const wrapper = (...args: any[]) => {\n      this.off(evt, wrapper as any)\n      ;(cb as any)(...args)\n    }\n    this.on(evt, wrapper as any)\n    return this\n  }\n\n  on<Key extends keyof T>(evt: Key, cb: T[Key]) {\n    const cbs = this._eventMap.get(evt) ?? []\n    cbs.push(cb as any)\n    this._eventMap.set(evt, cbs)\n    console.debug(`Subscribed to event: ${String(evt)}`)\n    return this\n  }\n\n  off<Key extends keyof T>(evt: Key, cb: T[Key]) {\n    const cbs = this._eventMap.get(evt)\n    if (cbs) {\n      this._eventMap.set(\n        evt,\n        cbs.filter((it) => it !== cb)\n      )\n      console.debug(`Unsubscribed from event: ${String(evt)}`)\n    }\n    return this\n  }\n\n  removeAllEventListeners(): void {\n    this._eventMap.clear()\n    console.debug('Removed all event listeners')\n  }\n\n  emit<Key extends keyof T>(evt: Key, ...args: any[]) {\n    const cbs = this._eventMap.get(evt) ?? []\n    for (const cb of cbs) {\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        cb && cb(...args)\n      } catch (e) {\n        // cb exception should not affect other callbacks\n        const error = e as Error\n        const details = error.stack || error.message\n        console.error(`Error handling event ${String(evt)}: ${details}`)\n      }\n    }\n    console.debug({ args }, `Emitted event: ${String(evt)}`)\n    return this\n  }\n}\n"],"names":[],"mappings":"AAAA,qDAAqD;;;;AAI9C,MAAM;IACH,YAAiD,IAAI,MAAK;IAElE,KAA0B,GAAQ,EAAE,EAAU,EAAE;QAC9C,MAAM,UAAU,CAAC,GAAG;YAClB,IAAI,CAAC,GAAG,CAAC,KAAK;YACZ,MAAc;QAClB;QACA,IAAI,CAAC,EAAE,CAAC,KAAK;QACb,OAAO,IAAI;IACb;IAEA,GAAwB,GAAQ,EAAE,EAAU,EAAE;QAC5C,MAAM,MAAM,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,EAAE;QACzC,IAAI,IAAI,CAAC;QACT,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK;QACxB,QAAQ,KAAK,CAAC,CAAC,qBAAqB,EAAE,OAAO,MAAM;QACnD,OAAO,IAAI;IACb;IAEA,IAAyB,GAAQ,EAAE,EAAU,EAAE;QAC7C,MAAM,MAAM,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC;QAC/B,IAAI,KAAK;YACP,IAAI,CAAC,SAAS,CAAC,GAAG,CAChB,KACA,IAAI,MAAM,CAAC,CAAC,KAAO,OAAO;YAE5B,QAAQ,KAAK,CAAC,CAAC,yBAAyB,EAAE,OAAO,MAAM;QACzD;QACA,OAAO,IAAI;IACb;IAEA,0BAAgC;QAC9B,IAAI,CAAC,SAAS,CAAC,KAAK;QACpB,QAAQ,KAAK,CAAC;IAChB;IAEA,KAA0B,GAAQ,EAAE,GAAG,IAAW,EAAE;QAClD,MAAM,MAAM,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,EAAE;QACzC,KAAK,MAAM,MAAM,IAAK;YACpB,IAAI;gBACF,oEAAoE;gBACpE,MAAM,MAAM;YACd,EAAE,OAAO,GAAG;gBACV,iDAAiD;gBACjD,MAAM,QAAQ;gBACd,MAAM,UAAU,MAAM,KAAK,IAAI,MAAM,OAAO;gBAC5C,QAAQ,KAAK,CAAC,CAAC,qBAAqB,EAAE,OAAO,KAAK,EAAE,EAAE,SAAS;YACjE;QACF;QACA,QAAQ,KAAK,CAAC;YAAE;QAAK,GAAG,CAAC,eAAe,EAAE,OAAO,MAAM;QACvD,OAAO,IAAI;IACb;AACF"}},
    {"offset": {"line": 584, "column": 0}, "map": {"version":3,"sources":["file:///Users/jalbo/Desktop/dev/blog/convoAI_ecommerce/lib/conversational-ai-api/utils/sub-render.ts"],"sourcesContent":["import { logger as agoraLogger } from '@agora-js/report'\nimport type { RTMEvents } from 'agora-rtm'\nimport _ from 'lodash'\n\nimport {\n  type EAgentState,\n  EChatMessageType,\n  type EConversationalAIAPIEvents,\n  EMessageType,\n  EModuleType,\n  ETranscriptHelperMode,\n  ETurnStatus,\n  type IAgentTranscription,\n  type IConversationalAIAPIEventHandlers,\n  type IMessageError,\n  type IMessageInterrupt,\n  type IMessageMetrics,\n  type IMessageSalStatus,\n  type IPresenceState,\n  type ITranscriptHelperItem,\n  type ITranscriptionBase,\n  type IUserTranscription,\n  type TDataChunkMessageWord,\n  type TQueueItem,\n  type TTranscriptHelperObjectWord\n} from '@/conversational-ai-api/type'\nimport { factoryFormatLog } from '@/conversational-ai-api/utils'\nimport { ELoggerType, logger } from '@/lib/logger'\n\nconst TAG = 'CovSubRenderController'\nconst CONSOLE_LOG_PREFIX = `[${TAG}]`\nconst SELF_USER_ID = 0\nconst VERSION = '1.8.0'\n\nconst DEFAULT_INTERVAL = 200 // milliseconds\nconst DEFAULT_CHUNK_INTERVAL = 100 // milliseconds, 10 char/s\n\nconst formatLog = factoryFormatLog({ tag: TAG })\n\n/**\n * CovSubRenderController is a service that manages the transcript messages from RTM messages.\n *\n * Best practices:\n *\n * 1. Bind `onChatHistoryUpdated` and `onAgentStateChanged` callbacks to handle chat history updates and agent state changes when initializing the service.\n *\n * 2. Call `run` method to start the service. One common use case is to call it after the user joins a channel.\n *\n * 3. Call `setPts` method to update the current PTS (Presentation Time Stamp) when receiving new media data. This is crucial for synchronizing the transcripts with the media playback.\n *\n * 4. [Cleanup] Call `cleanup` method to reset the service state when leaving a channel or when the service is no longer needed. This will clear the chat history, queue, and other internal states.\n */\nexport class CovSubRenderController {\n  private static NAME = TAG\n  private static VERSION = VERSION\n  private callMessagePrint: (type: ELoggerType, ...args: unknown[]) => void\n  public static self_uid = SELF_USER_ID\n\n  private _mode: ETranscriptHelperMode = ETranscriptHelperMode.UNKNOWN\n  private _queue: TQueueItem[] = []\n  private _interval: number\n  private _intervalRef: NodeJS.Timeout | null = null\n  private _pts: number = 0 // current pts\n  private _lastPoppedQueueItem: TQueueItem | null | undefined = null\n  private _isRunning: boolean = false\n  private _agentMessageState: {\n    state: EAgentState\n    turn_id: string | number\n    timestamp: number\n  } | null = null\n  private _transcriptChunk: {\n    index: number\n    data: IAgentTranscription\n    uid: string\n  } | null = null\n\n  public chatHistory: ITranscriptHelperItem<\n    Partial<IUserTranscription | IAgentTranscription>\n  >[] = []\n  public onChatHistoryUpdated:\n    | IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.TRANSCRIPT_UPDATED]\n    | null = null\n  public onAgentStateChanged:\n    | IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.AGENT_STATE_CHANGED]\n    | null\n  public onAgentInterrupted:\n    | IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.AGENT_INTERRUPTED]\n    | null = null\n  public onDebugLog:\n    | IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.DEBUG_LOG]\n    | null = null\n  public onAgentMetrics:\n    | IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.AGENT_METRICS]\n    | null = null\n  public onAgentError:\n    | IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.AGENT_ERROR]\n    | null = null\n  public onMessageReceipt:\n    | IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.MESSAGE_RECEIPT_UPDATED]\n    | null = null\n  public onMessageError:\n    | IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.MESSAGE_ERROR]\n    | null = null\n  public onMessageSalStatus:\n    | IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.MESSAGE_SAL_STATUS]\n    | null = null\n\n  constructor(\n    options: {\n      messageCacheTimeout?: number\n      interval?: number\n      onChatHistoryUpdated?: IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.TRANSCRIPT_UPDATED]\n      onAgentStateChanged?: IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.AGENT_STATE_CHANGED]\n      onAgentInterrupted?: IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.AGENT_INTERRUPTED]\n      onDebugLog?: IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.DEBUG_LOG]\n      onAgentMetrics?: IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.AGENT_METRICS]\n      onAgentError?: IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.AGENT_ERROR]\n      onMessageReceipt?: IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.MESSAGE_RECEIPT_UPDATED]\n      onMessageError?: IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.MESSAGE_ERROR]\n      onMessageSalStatus?: IConversationalAIAPIEventHandlers[EConversationalAIAPIEvents.MESSAGE_SAL_STATUS]\n    } = {}\n  ) {\n    this.callMessagePrint = (\n      type: ELoggerType = ELoggerType.debug,\n      ...args: unknown[]\n    ) => {\n      logger[type](formatLog(...args))\n      this.onDebugLog?.(`[${type}] ${formatLog(...args)}`)\n      agoraLogger[type](...args)\n    }\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `${CovSubRenderController.NAME} initialized, version: ${CovSubRenderController.VERSION}`\n    )\n    this._interval = options.interval ?? DEFAULT_INTERVAL\n    this.onChatHistoryUpdated = options.onChatHistoryUpdated ?? null\n    this.onAgentStateChanged = options.onAgentStateChanged ?? null\n    this.onAgentInterrupted = options.onAgentInterrupted ?? null\n    this.onDebugLog = options.onDebugLog ?? null\n    this.onAgentMetrics = options.onAgentMetrics ?? null\n    this.onAgentError = options.onAgentError ?? null\n    this.onMessageReceipt = options.onMessageReceipt ?? null\n    this.onMessageError = options.onMessageError ?? null\n    this.onMessageSalStatus = options.onMessageSalStatus ?? null\n  }\n\n  private _preSetupInterval() {\n    if (!this._isRunning) {\n      console.error(CONSOLE_LOG_PREFIX, 'Message service is not running')\n      this.callMessagePrint(\n        ELoggerType.error,\n        '_preSetupInterval',\n        'Message service is not running'\n      )\n      return\n    }\n  }\n\n  private _setupIntervalForWords(options?: { isForce?: boolean }) {\n    this._preSetupInterval()\n    // if force: clean older and reset interval\n    if (options?.isForce) {\n      if (this._intervalRef) {\n        clearInterval(this._intervalRef)\n        this._intervalRef = null\n      }\n      this._intervalRef = setInterval(\n        this._handleQueue.bind(this),\n        this._interval\n      )\n      return\n    }\n    // else(if not forced): skip if interval is already set, otherwise set an interval\n    if (this._intervalRef) {\n      return\n    }\n    this._intervalRef = setInterval(\n      this._handleQueue.bind(this),\n      this._interval\n    )\n  }\n\n  private _handleQueue() {\n    const queueLength = this._queue.length\n    // empty queue, skip\n    if (queueLength === 0) {\n      // console.debug(CONSOLE_LOG_PREFIX, 'Queue is empty, skip')\n      return\n    }\n    const curPTS = this._pts\n    // only one item, update chatHistory with queueItem\n    if (queueLength === 1) {\n      // console.debug(\n      //   CONSOLE_LOG_PREFIX,\n      //   'Queue has only one item, update chatHistory',\n      //   JSON.stringify(this._queue[0])\n      // )\n      const queueItem = this._queue[0]\n      this._handleTurnObj(queueItem, curPTS)\n      this._mutateChatHistory()\n      return\n    }\n    if (queueLength > 2) {\n      // console.error(\n      //   CONSOLE_LOG_PREFIX,\n      //   'Queue length is greater than 2, but it should not happen'\n      // )\n      this.callMessagePrint(\n        ELoggerType.error,\n        'Queue length is greater than 2, but it should not happen'\n      )\n    }\n    // assume the queueLength is 2\n    if (queueLength > 1) {\n      this._queue = this._queue.sort((a, b) => a.turn_id - b.turn_id)\n      const nextItem = this._queue[this._queue.length - 1]\n      const lastItem = this._queue[this._queue.length - 2]\n      // check if nextItem is started\n      const firstWordOfNextItem = nextItem.words[0]\n      // if firstWordOfNextItem.start_ms > curPTS, work on lastItem\n      if (firstWordOfNextItem.start_ms > curPTS) {\n        this._handleTurnObj(lastItem, curPTS)\n        this._mutateChatHistory()\n        return\n      }\n      // if firstWordOfNextItem.start_ms <= curPTS, work on nextItem, assume lastItem is interrupted(and drop it)\n      const lastItemCorrespondingChatHistoryItem = this.chatHistory.find(\n        (item) =>\n          item.turn_id === lastItem.turn_id &&\n          item.stream_id === lastItem.stream_id\n      )\n      if (!lastItemCorrespondingChatHistoryItem) {\n        this.callMessagePrint(\n          ELoggerType.warn,\n          'No corresponding chatHistory item found',\n          lastItem\n        )\n        return\n      }\n      lastItemCorrespondingChatHistoryItem.status = ETurnStatus.INTERRUPTED\n      this._lastPoppedQueueItem = this._queue.shift()\n      // handle nextItem\n      this._handleTurnObj(nextItem, curPTS)\n      this._mutateChatHistory()\n      return\n    }\n  }\n\n  private _handleTurnObj(queueItem: TQueueItem, curPTS: number) {\n    let correspondingChatHistoryItem = this.chatHistory.find(\n      (item) =>\n        item.turn_id === queueItem.turn_id &&\n        item.stream_id === queueItem.stream_id\n    )\n    this.callMessagePrint(\n      ELoggerType.debug,\n      'handleTurnObj',\n      queueItem,\n      'correspondingChatHistoryItem',\n      correspondingChatHistoryItem\n    )\n    if (!correspondingChatHistoryItem) {\n      this.callMessagePrint(\n        ELoggerType.debug,\n        'handleTurnObj',\n        'No corresponding chatHistory item found',\n        'push to chatHistory'\n      )\n      correspondingChatHistoryItem = {\n        turn_id: queueItem.turn_id,\n        uid: queueItem.uid,\n        stream_id: queueItem.stream_id,\n        _time: new Date().getTime(),\n        text: '',\n        status: queueItem.status,\n        metadata: queueItem\n      }\n      this._appendChatHistory(correspondingChatHistoryItem)\n    }\n    // update correspondingChatHistoryItem._time for chatHistory auto-scroll\n    correspondingChatHistoryItem._time = new Date().getTime()\n    // update correspondingChatHistoryItem.metadata\n    correspondingChatHistoryItem.metadata = queueItem\n    // update correspondingChatHistoryItem.status if queueItem.status is interrupted(from message.interrupt event)\n    if (queueItem.status === ETurnStatus.INTERRUPTED) {\n      correspondingChatHistoryItem.status = ETurnStatus.INTERRUPTED\n    }\n    // pop all valid word items(those word.start_ms <= curPTS) in queueItem\n    const validWords: TTranscriptHelperObjectWord[] = []\n    const restWords: TTranscriptHelperObjectWord[] = []\n    for (const word of queueItem.words) {\n      if (word.start_ms <= curPTS) {\n        validWords.push(word)\n      } else {\n        restWords.push(word)\n      }\n    }\n    // check if restWords is empty\n    const isRestWordsEmpty = restWords.length === 0\n    // check if validWords last word is final\n    const isLastWordFinal =\n      validWords[validWords.length - 1]?.word_status !== ETurnStatus.IN_PROGRESS\n    // if restWords is empty and validWords last word is final, this turn is ended\n    if (isRestWordsEmpty && isLastWordFinal) {\n      // update chatHistory with queueItem\n      correspondingChatHistoryItem.text = queueItem.text\n      correspondingChatHistoryItem.status = queueItem.status\n      // pop queueItem\n      this._lastPoppedQueueItem = this._queue.shift()\n      return\n    }\n    // if restWords is not empty, update correspondingChatHistoryItem.text\n    const validWordsText = validWords\n      .filter((word) => word.start_ms <= this._pts)\n      .map((word) => word.word)\n      .join('')\n    correspondingChatHistoryItem.text = validWordsText\n    // if validWords last word is interrupted, this turn is ended\n    const isLastWordInterrupted =\n      validWords[validWords.length - 1]?.word_status === ETurnStatus.INTERRUPTED\n    if (isLastWordInterrupted) {\n      // pop queueItem\n      this._lastPoppedQueueItem = this._queue.shift()\n      return\n    }\n    return\n  }\n\n  private _mutateChatHistory() {\n    // console.debug(CONSOLE_LOG_PREFIX, 'Mutate chatHistory', this.chatHistory)\n    this.callMessagePrint(\n      ELoggerType.debug,\n      '>>> onChatHistoryUpdated',\n      `pts: ${this._pts}, chatHistory length: ${this.chatHistory.length}`,\n      this.chatHistory\n        .map((item) => `${item.uid}:${item.text}[status: ${item.status}]`)\n        .join('\\n')\n    )\n    this.onChatHistoryUpdated?.(this.chatHistory)\n  }\n\n  private _appendChatHistory(\n    item: ITranscriptHelperItem<\n      Partial<IUserTranscription | IAgentTranscription>\n    >\n  ) {\n    // if item.turn_id is 0, append to the front of chatHistory(greeting message)\n    if (item.turn_id === 0) {\n      this.chatHistory = [item, ...this.chatHistory]\n    } else {\n      this.chatHistory.push(item)\n    }\n  }\n\n  private _interruptQueue(options: { turn_id: number; start_ms: number }) {\n    const turn_id = options.turn_id\n    const start_ms = options.start_ms\n    const correspondingQueueItem = this._queue.find(\n      (item) => item.turn_id === turn_id\n    )\n    this.callMessagePrint(\n      ELoggerType.debug,\n      'interruptQueue',\n      `turn_id: ${turn_id}, start_ms: ${start_ms}, correspondingQueueItem: ${correspondingQueueItem}`\n    )\n    if (!correspondingQueueItem) {\n      // console.debug(\n      //   CONSOLE_LOG_PREFIX,\n      //   'No corresponding queue item found',\n      //   options\n      // )\n      return\n    }\n    // if correspondingQueueItem exists, update its status to interrupted\n    correspondingQueueItem.status = ETurnStatus.INTERRUPTED\n    // split words into two parts, set left one word and all right words to interrupted\n    const leftWords = correspondingQueueItem.words.filter(\n      (word) => word.start_ms <= start_ms\n    )\n    const rightWords = correspondingQueueItem.words.filter(\n      (word) => word.start_ms > start_ms\n    )\n    // check if leftWords is empty\n    const isLeftWordsEmpty = leftWords.length === 0\n    if (isLeftWordsEmpty) {\n      // if leftWords is empty, set all words to interrupted\n      correspondingQueueItem.words.forEach((word) => {\n        word.word_status = ETurnStatus.INTERRUPTED\n      })\n    } else {\n      // if leftWords is not empty, set leftWords[leftWords.length - 1].word_status to interrupted\n      leftWords[leftWords.length - 1].word_status = ETurnStatus.INTERRUPTED\n      // workaround: pts < interrupt.start_ms, and interrupt will be ignored\n      if (leftWords?.[leftWords.length - 2]) {\n        leftWords[leftWords.length - 2].word_status = ETurnStatus.INTERRUPTED\n      }\n      // and all right words to interrupted\n      rightWords.forEach((word) => {\n        word.word_status = ETurnStatus.INTERRUPTED\n      })\n      // update words\n      correspondingQueueItem.words = [...leftWords, ...rightWords]\n    }\n  }\n\n  private _pushToQueue(data: {\n    turn_id: number\n    words: TTranscriptHelperObjectWord[]\n    text: string\n    status: ETurnStatus\n    stream_id: number\n    uid: string\n  }) {\n    const targetQueueItem = this._queue.find(\n      (item) => item.turn_id === data.turn_id\n    )\n    const latestTurnId = this._queue.reduce((max, item) => {\n      return Math.max(max, item.turn_id)\n    }, 0)\n    // if not found, push to queue or drop if turn_id is less than latestTurnId\n    if (!targetQueueItem) {\n      // drop if turn_id is less than latestTurnId\n      if (data.turn_id < latestTurnId) {\n        this.callMessagePrint(\n          ELoggerType.debug,\n          `[Word Mode]`,\n          `[${data.uid}]`,\n          'Drop message with turn_id less than latestTurnId',\n          `turn_id: ${data.turn_id}, latest turn_id: ${latestTurnId}`,\n          data\n        )\n        return\n      }\n      const newQueueItem = {\n        turn_id: data.turn_id,\n        text: data.text,\n        words: this.sortWordsWithStatus(data.words, data.status),\n        status: data.status,\n        stream_id: data.stream_id,\n        uid: data.uid\n      }\n      this.callMessagePrint(\n        ELoggerType.debug,\n        `[Word Mode]`,\n        `[${data.uid}]`,\n        'push to queue',\n        newQueueItem\n      )\n      // push to queue\n      this._queue.push(newQueueItem)\n      return\n    }\n    // if found, update text, words(sorted with status) and turn_status\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `[Word Mode]`,\n      `[${data.uid}]`,\n      'update queue item',\n      targetQueueItem,\n      data\n    )\n    targetQueueItem.text = data.text\n    targetQueueItem.words = this.sortWordsWithStatus(\n      [...targetQueueItem.words, ...data.words],\n      data.status\n    )\n    // if targetQueueItem.status is end, and data.status is in_progress, skip status update (unexpected case)\n    if (\n      targetQueueItem.status !== ETurnStatus.IN_PROGRESS &&\n      data.status === ETurnStatus.IN_PROGRESS\n    ) {\n      return\n    }\n    targetQueueItem.status = data.status\n  }\n\n  private _teardownInterval() {\n    if (this._intervalRef) {\n      clearInterval(this._intervalRef)\n      this._intervalRef = null\n    }\n  }\n\n  protected sortWordsWithStatus(\n    words: TDataChunkMessageWord[],\n    turn_status: ETurnStatus\n  ) {\n    if (words.length === 0) {\n      return words\n    }\n    const sortedWords: TTranscriptHelperObjectWord[] = words\n      .map((word) => ({\n        ...word,\n        word_status: ETurnStatus.IN_PROGRESS\n      }))\n      .sort((a, b) => a.start_ms - b.start_ms)\n      .reduce((acc, curr) => {\n        // Only add if start_ms is unique\n        if (!acc.find((word) => word.start_ms === curr.start_ms)) {\n          acc.push(curr)\n        }\n        return acc\n      }, [] as TTranscriptHelperObjectWord[])\n    const isMessageFinal = turn_status !== ETurnStatus.IN_PROGRESS\n    if (isMessageFinal) {\n      sortedWords[sortedWords.length - 1].word_status = turn_status\n    }\n    return sortedWords\n  }\n\n  protected handleTextMessage(uid: string, message: IUserTranscription) {\n    const turn_id = message.turn_id\n    const text = message.text || ''\n    const stream_id = message.stream_id\n    const turn_status = ETurnStatus.END\n\n    const targetChatHistoryItem = this.chatHistory.find(\n      (item) => item.turn_id === turn_id && item.stream_id === stream_id\n    )\n    // if not found, push to chatHistory\n    if (!targetChatHistoryItem) {\n      this.callMessagePrint(\n        ELoggerType.debug,\n        `[Text Mode]`,\n        `[${uid}]`,\n        'new item',\n        message\n      )\n      this._appendChatHistory({\n        turn_id,\n        uid: message.stream_id\n          ? `${CovSubRenderController.self_uid}`\n          : `${uid}`,\n        stream_id,\n        _time: new Date().getTime(),\n        text,\n        status: turn_status,\n        metadata: message\n      })\n    } else {\n      // if found, update text and status\n      targetChatHistoryItem.text = text\n      targetChatHistoryItem.status = turn_status\n      targetChatHistoryItem.metadata = message\n      targetChatHistoryItem._time = new Date().getTime()\n      this.callMessagePrint(\n        ELoggerType.debug,\n        `[Text Mode]`,\n        `[${uid}]`,\n        targetChatHistoryItem\n      )\n    }\n    this._mutateChatHistory()\n  }\n\n  private _handleTranscriptChunk() {\n    if (!this._transcriptChunk) {\n      this.callMessagePrint(\n        ELoggerType.warn,\n        `[${ETranscriptHelperMode.CHUNK} Mode]`,\n        '_handleTranscriptChunk',\n        'missing _transcriptChunk'\n      )\n      return\n    }\n    const currentIdx = this._transcriptChunk.index\n    const currentTranscript = this._transcriptChunk.data\n    const currentMaxLength = currentTranscript.text.length\n    const uid = this._transcriptChunk.uid\n\n    const nextIdx =\n      currentIdx + 1 >= currentMaxLength ? currentMaxLength : currentIdx + 1\n    this._transcriptChunk.index = nextIdx\n    const validTranscriptString = currentTranscript.text.substring(0, nextIdx)\n    const isValidTranscriptStringEnded =\n      validTranscriptString.length > 0 &&\n      currentTranscript.turn_status !== ETurnStatus.IN_PROGRESS &&\n      validTranscriptString.length === currentTranscript.text.length\n\n    const targetChatHistoryItem = this.chatHistory.find(\n      (item) =>\n        item.turn_id === currentTranscript.turn_id &&\n        item.stream_id === currentTranscript.stream_id\n    )\n    // if not found, push to chatHistory\n    if (!targetChatHistoryItem) {\n      this.callMessagePrint(\n        ELoggerType.debug,\n        `[${ETranscriptHelperMode.CHUNK} Mode]`,\n        `[${uid}]`,\n        'new transcriptChunk',\n        this._transcriptChunk\n      )\n      this._appendChatHistory({\n        turn_id: currentTranscript.turn_id,\n        uid: currentTranscript.stream_id\n          ? `${CovSubRenderController.self_uid}`\n          : `${uid}`,\n        stream_id: currentTranscript.stream_id,\n        _time: Date.now(),\n        text: validTranscriptString,\n        status: currentTranscript.turn_status,\n        metadata: currentTranscript\n      })\n    } else {\n      // if found, update text and status\n      targetChatHistoryItem.text = validTranscriptString\n      targetChatHistoryItem.status = isValidTranscriptStringEnded\n        ? currentTranscript.turn_status\n        : targetChatHistoryItem.status\n      targetChatHistoryItem.metadata = currentTranscript\n      targetChatHistoryItem._time = Date.now()\n      this.callMessagePrint(\n        ELoggerType.debug,\n        `[${ETranscriptHelperMode.CHUNK} Mode]`,\n        `[${uid}]`,\n        'update transcriptChunk',\n        targetChatHistoryItem\n      )\n    }\n    this._mutateChatHistory()\n  }\n\n  protected handleChunkTextMessage(uid: string, message: IAgentTranscription) {\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `[${ETranscriptHelperMode.CHUNK} Mode]`,\n      `[${uid}]`,\n      'new item',\n      message\n    )\n    // 0. check turn_id, teardown interval if new turn\n    if (\n      this._transcriptChunk &&\n      this._transcriptChunk.data.turn_id < message.turn_id\n    ) {\n      this._teardownInterval()\n      // set chathistory items turn_status to ended\n      const lastChatHistory = this.chatHistory.find(\n        (item) =>\n          item.turn_id === this._transcriptChunk?.data.turn_id &&\n          item.uid === uid\n      )\n      if (lastChatHistory) {\n        lastChatHistory.status = ETurnStatus.END\n      }\n      // set _transcriptChunk to null\n      this._transcriptChunk = null\n    }\n    // 1. update _transcriptChunk\n    this._transcriptChunk = {\n      index: this._transcriptChunk?.index ?? 0,\n      data: message,\n      uid\n    }\n    // 2. check if interval is set, if not, set it\n    if (!this._intervalRef) {\n      this._intervalRef = setInterval(\n        this._handleTranscriptChunk.bind(this),\n        this._interval\n      )\n    }\n  }\n\n  protected handleMessageInterrupt(uid: string, message: IMessageInterrupt) {\n    this.callMessagePrint(\n      ELoggerType.debug,\n      '<<< [onInterrupted]',\n      `pts: ${this._pts}, uid: ${uid}`,\n      message\n    )\n    const turn_id = message.turn_id\n    // workaround: pts < interrupt.start_ms, and interrupt will be ignored\n    const start_ms = _.min([message.start_ms, this._pts]) || message.start_ms\n    this._interruptQueue({\n      turn_id,\n      start_ms\n    })\n    // interrupt chunk\n    if (this._transcriptChunk) {\n      this._teardownInterval()\n      // set chathistory items turn_status to ended\n      const lastChatHistory = this.chatHistory.find(\n        (item) =>\n          item.turn_id === this._transcriptChunk?.data.turn_id &&\n          item.uid === uid\n      )\n      if (lastChatHistory) {\n        lastChatHistory.status = ETurnStatus.INTERRUPTED\n      }\n      // set _transcriptChunk to null\n      this._transcriptChunk = null\n    }\n    this._mutateChatHistory()\n    this.onAgentInterrupted?.(`${uid}`, {\n      turnID: turn_id,\n      timestamp: start_ms\n    })\n  }\n\n  protected handleMessageMetrics(uid: string, message: IMessageMetrics) {\n    // this.callMessagePrint(\n    //   ELoggerType.debug,\n    //   '<<< [onMetrics]',\n    //   `pts: ${this._pts}, uid: ${uid}`,\n    //   message\n    // )\n    const latency_ms = message.latency_ms\n    const messageModule = message.module\n    const metric_name = message.metric_name\n\n    if (!Object.values(EModuleType).includes(messageModule)) {\n      this.callMessagePrint(ELoggerType.warn, 'Unknown metric module:', message)\n      return\n    }\n\n    this.onAgentMetrics?.(`${uid}`, {\n      type: messageModule,\n      name: metric_name,\n      value: latency_ms,\n      timestamp: message.send_ts\n    })\n  }\n\n  protected handleMessageSalStatus(uid: string, message: IMessageSalStatus) {\n    this.callMessagePrint(ELoggerType.debug, 'handleMessageSalStatus', message)\n    this.onMessageSalStatus?.(`${uid}`, message)\n  }\n\n  protected handleMessageError(uid: string, message: IMessageError) {\n    // this.callMessagePrint(\n    //   ELoggerType.debug,\n    //   '<<< [onError]',\n    //   `pts: ${this._pts}, uid: ${uid}`,\n    //   message\n    // )\n    const errorCode = message.code || -1\n    const errorMessage = message.message\n    const messageModule = message.module\n\n    if (!Object.values(EModuleType).includes(messageModule)) {\n      this.callMessagePrint(ELoggerType.warn, 'Unknown error module:', message)\n      return\n    }\n\n    if (messageModule === EModuleType.CONTEXT) {\n      try {\n        const messageData = JSON.parse(errorMessage)\n        const errorPayload = {\n          type:\n            messageData?.module === 'picture'\n              ? EChatMessageType.IMAGE\n              : EChatMessageType.UNKNOWN,\n          code: errorCode,\n          message: errorMessage,\n          timestamp: (message?.send_ts as number) || Date.now()\n        }\n        this.onMessageError?.(`${uid}`, errorPayload)\n      } catch (error: unknown) {\n        this.callMessagePrint(\n          ELoggerType.error,\n          'Failed to parse context error message',\n          error,\n          message\n        )\n      }\n    }\n\n    this.onAgentError?.(`${uid}`, {\n      type: messageModule,\n      code: errorCode,\n      message: errorMessage,\n      timestamp: (message?.send_ts as number) || Date.now()\n    })\n  }\n\n  // current only used for image messages\n  protected handleMessageInfo(uid: string, message: Record<string, unknown>) {\n    try {\n      const messageStr = (message?.message as string) || ''\n      const messageObj = JSON.parse(messageStr)\n      const moduleType = message?.module as EModuleType\n      const turnId = message?.turn_id as number\n      if (!messageStr || !messageObj || !moduleType || !turnId) {\n        this.callMessagePrint(\n          ELoggerType.error,\n          'handleMessageInfo',\n          'Invalid message object',\n          message\n        )\n        return\n      }\n      const messageType =\n        message?.resource_type === 'picture'\n          ? EChatMessageType.IMAGE\n          : EChatMessageType.UNKNOWN\n      this.onMessageReceipt?.(uid, {\n        moduleType,\n        messageType,\n        message: messageStr,\n        turnId\n      })\n    } catch (error: unknown) {\n      this.callMessagePrint(\n        ELoggerType.debug,\n        'handleMessageInfo',\n        'Failed to parse message string from image info message',\n        error,\n        message\n      )\n    }\n  }\n\n  public handleAgentStatus(metadata: IPresenceState) {\n    // this.callMessagePrint(\n    //   ELoggerType.debug,\n    //   'handleAgentStatus',\n    //   `pts: ${this._pts}, uid: ${metadata.publisher}`,\n    //   `prev-state: ${this._agentMessageState}, state: ${metadata.stateChanged.state}, turn_id: ${metadata.stateChanged.turn_id}, timestamp: ${metadata.stateChanged.timestamp}`\n    // )\n    const message = metadata.stateChanged\n    const currentTurnId = _.toNumber(message.turn_id) || 0\n    if (_.toNumber(this._agentMessageState?.turn_id || 0) > currentTurnId) {\n      this.callMessagePrint(\n        ELoggerType.debug,\n        'handleAgentStatus',\n        'ignore older message(turn_id)'\n      )\n      return\n    }\n    // check if message is older(by timestamp) than previous one, if so, skip\n    const currentMsgTs = metadata.timestamp\n    if (_.toNumber(this._agentMessageState?.timestamp || 0) >= currentMsgTs) {\n      // console.debug(\n      //   CONSOLE_LOG_PREFIX,\n      //   'handleAgentStatus',\n      //   'ignore older message(timestamp)',\n      //   message?.timestamp,\n      //   currentMsgTs\n      // )\n      this.callMessagePrint(\n        ELoggerType.debug,\n        'handleAgentStatus',\n        'ignore older message(timestamp)'\n      )\n      return\n    }\n    this.callMessagePrint(\n      ELoggerType.debug,\n      '>>> handleAgentStatus',\n      `pts: ${this._pts}, uid: ${metadata.publisher}`,\n      `prev-state: ${this._agentMessageState?.state}, prev-turn_id: ${this._agentMessageState?.turn_id}, prev-timestamp: ${this._agentMessageState?.timestamp}`,\n      `current-state: ${metadata.stateChanged.state}, turn_id: ${metadata.stateChanged.turn_id}, timestamp: ${metadata.timestamp}`\n    )\n    // set current message state\n    this._agentMessageState = {\n      state: message.state,\n      turn_id: message.turn_id,\n      timestamp: currentMsgTs\n    }\n    this.onAgentStateChanged?.(metadata.publisher, {\n      state: message.state,\n      turnID: _.toNumber(message.turn_id),\n      timestamp: currentMsgTs,\n      reason: ''\n    })\n  }\n\n  protected handleWordAgentMessage(uid: string, message: IAgentTranscription) {\n    // drop message if turn_status is undefined\n    if (typeof message.turn_status === 'undefined') {\n      this.callMessagePrint(\n        ELoggerType.debug,\n        `[Word Mode]`,\n        `[${uid}]`,\n        'Drop message with undefined turn_status',\n        message.turn_id\n      )\n      return\n    }\n\n    const turn_id = message.turn_id\n    const text = message.text || ''\n    const words = message.words || []\n    const stream_id = message.stream_id\n    const lastPoppedQueueItemTurnId = this._lastPoppedQueueItem?.turn_id\n    // drop message if turn_id is less than last popped queue item\n    // except for the first turn(greeting message, turn_id is 0)\n    if (\n      lastPoppedQueueItemTurnId &&\n      turn_id !== 0 &&\n      turn_id <= lastPoppedQueueItemTurnId\n    ) {\n      this.callMessagePrint(\n        ELoggerType.debug,\n        `[Word Mode]`,\n        `[${uid}]`,\n        'Drop message with turn_id less than last popped queue item',\n        `turn_id: ${turn_id}, last popped queue item turn_id: ${lastPoppedQueueItemTurnId}`\n      )\n      return\n    }\n    this._pushToQueue({\n      uid: message.stream_id ? `${CovSubRenderController.self_uid}` : `${uid}`,\n      turn_id,\n      words,\n      text,\n      status: message.turn_status,\n      stream_id\n    })\n  }\n\n  public setMode(mode: ETranscriptHelperMode) {\n    if (this._mode !== ETranscriptHelperMode.UNKNOWN) {\n      this.callMessagePrint(\n        ELoggerType.warn,\n        `Mode should only be set once, but it is set[${mode}] again`,\n        'current mode:',\n        this._mode\n      )\n      return\n    }\n    if (mode === ETranscriptHelperMode.UNKNOWN) {\n      this.callMessagePrint(ELoggerType.warn, 'Unknown mode should not be set')\n      return\n    }\n    if (mode === ETranscriptHelperMode.CHUNK) {\n      // set interval to chunk interval\n      this._interval = DEFAULT_CHUNK_INTERVAL\n    } else {\n      // set interval to default interval\n      this._interval = DEFAULT_INTERVAL\n    }\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `setMode`,\n      ETranscriptHelperMode.TEXT\n    )\n    this._mode = mode\n  }\n\n  public handleMessage<T extends ITranscriptionBase>(\n    message: T,\n    options: {\n      publisher: RTMEvents.MessageEvent['publisher']\n    }\n  ) {\n    const messageObject = message?.object\n    if (!Object.values(EMessageType).includes(messageObject)) {\n      this.callMessagePrint(\n        ELoggerType.info,\n        `<<< [unknown message]`,\n        options,\n        message\n      )\n      return\n    }\n\n    const isAgentMessage = message.object === EMessageType.AGENT_TRANSCRIPTION\n    const isUserMessage = message.object === EMessageType.USER_TRANSCRIPTION\n    const isMessageInterrupt = message.object === EMessageType.MSG_INTERRUPTED\n    const isMessageMetrics = message.object === EMessageType.MSG_METRICS\n    const isMessageError = message.object === EMessageType.MSG_ERROR\n    // const isMessageState = message.object === EMessageType.MSG_STATE\n    const isMessageInfo = message.object === EMessageType.MESSAGE_INFO\n    const isMessageSalStatus =\n      message.object === EMessageType.MESSAGE_SAL_STATUS\n\n    // set mode (only once)\n    if (isAgentMessage && this._mode === ETranscriptHelperMode.UNKNOWN) {\n      // 2025-09-28 check if words array is empty or not undefined, and set mode\n      if (\n        !message.words ||\n        (Array.isArray(message.words) && message.words.length === 0)\n      ) {\n        this.setMode(ETranscriptHelperMode.TEXT)\n      } else {\n        this._setupIntervalForWords({ isForce: true })\n        this.setMode(ETranscriptHelperMode.WORD)\n      }\n    }\n\n    // handle Agent Message\n    if (isAgentMessage && this._mode === ETranscriptHelperMode.WORD) {\n      this._setupIntervalForWords({ isForce: false })\n      this.handleWordAgentMessage(\n        options.publisher,\n        message as unknown as IAgentTranscription\n      )\n      return\n    }\n    if (isAgentMessage && this._mode === ETranscriptHelperMode.TEXT) {\n      this.handleTextMessage(\n        options.publisher,\n        message as unknown as IUserTranscription\n      )\n      return\n    }\n    if (isAgentMessage && this._mode === ETranscriptHelperMode.CHUNK) {\n      this.handleChunkTextMessage(\n        options.publisher,\n        message as unknown as IAgentTranscription\n      )\n      return\n    }\n    // handle User Message\n    if (isUserMessage) {\n      this.handleTextMessage(\n        options.publisher,\n        message as unknown as IUserTranscription\n      )\n      return\n    }\n    // handle Message Interrupt\n    if (isMessageInterrupt) {\n      this.handleMessageInterrupt(\n        options.publisher,\n        message as unknown as IMessageInterrupt\n      )\n      return\n    }\n    // if (isMessageState) {\n    //   this.handleAgentStatus(message as unknown as IMessageState)\n    //   return\n    // }\n    if (isMessageInfo) {\n      this.handleMessageInfo(\n        options.publisher,\n        message as unknown as Record<string, unknown>\n      )\n      return\n    }\n    if (isMessageMetrics) {\n      this.handleMessageMetrics(\n        options.publisher,\n        message as unknown as IMessageMetrics\n      )\n      return\n    }\n    if (isMessageError) {\n      this.handleMessageError(\n        options.publisher,\n        message as unknown as IMessageError\n      )\n      return\n    }\n\n    if (isMessageSalStatus) {\n      this.handleMessageSalStatus(options.publisher, message as unknown as any)\n      return\n    }\n  }\n\n  public run() {\n    this._isRunning = true\n  }\n\n  public setPts(pts: number) {\n    if (this._pts < pts && pts !== 0) {\n      this._pts = pts\n    }\n  }\n\n  public cleanup() {\n    // console.debug(CONSOLE_LOG_PREFIX, 'Cleanup message service')\n    this.callMessagePrint(ELoggerType.debug, 'cleanup')\n    this._isRunning = false\n    this._teardownInterval()\n    // cleanup queue\n    this._queue = []\n    this._lastPoppedQueueItem = null\n    this._pts = 0\n    // cleanup chatHistory\n    this.chatHistory = []\n    // cleanup mode\n    this._mode = ETranscriptHelperMode.UNKNOWN\n    this._agentMessageState = null\n    this._transcriptChunk = null\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1314, "column": 0}, "map": {"version":3,"sources":["file:///Users/jalbo/Desktop/dev/blog/convoAI_ecommerce/lib/conversational-ai-api/index.ts"],"sourcesContent":["import { logger as agoraLogger } from '@agora-js/report'\nimport type { IAgoraRTCClient } from 'agora-rtc-sdk-ng'\nimport type { ChannelType, RTMClient, RTMEvents } from 'agora-rtm'\n\nimport {\n  type EAgentState,\n  EChatMessagePriority,\n  EChatMessageType,\n  EConversationalAIAPIEvents,\n  EMessageType,\n  ERTCEvents,\n  ERTMEvents,\n  ETranscriptHelperMode,\n  type IAgentTranscription,\n  type IChatMessageImage,\n  type IChatMessageText,\n  type IConversationalAIAPIEventHandlers,\n  type IMessageSalStatus,\n  type ITranscriptHelperItem,\n  type IUserTranscription,\n  NotFoundError,\n  type TAgentMetric,\n  type TMessageReceipt,\n  type TModuleError,\n  type TStateChangeEvent\n} from './type'\nimport { factoryFormatLog } from './utils'\nimport { EventHelper } from './utils/event'\nimport { CovSubRenderController } from './utils/sub-render'\n\nconst TAG = 'ConversationalAIAPI'\n// const CONSOLE_LOG_PREFIX = `[${TAG}]`\nconst VERSION = '1.8.0'\n\nconst formatLog = factoryFormatLog({ tag: TAG })\n\nexport interface IConversationalAIAPIConfig {\n  rtcEngine: IAgoraRTCClient\n  rtmEngine: RTMClient\n  renderMode?: ETranscriptHelperMode\n  enableLog?: boolean\n}\n\n/**\n * A class that manages conversational AI interactions through Agora's RTC and RTM services.\n *\n * Provides functionality to handle real-time communication between users and AI agents,\n * including message processing, state management, and event handling. It integrates with\n * Agora's RTC client for audio streaming and RTM client for messaging.\n *\n * Key features\n * - Singleton instance management\n * - RTC and RTM event handling\n * - Chat history and transcription management\n * - Agent state monitoring\n * - Debug logging\n * - Event subscription and management through EventHelper\n *\n * @remarks\n * - Must be initialized with {@link IConversationalAIAPIConfig} before use\n * - Only one instance can exist at a time\n * - Requires both RTC and RTM engines to be properly configured\n * - Events are emitted for state changes, transcriptions, and errors\n * - Extends EventHelper to provide event subscription capabilities\n *\n * @example\n * Basic initialization and usage:\n * ```typescript\n * const api = ConversationalAIAPI.init({\n *   rtcEngine: rtcClient,\n *   rtmEngine: rtmClient,\n *   renderMode: ETranscriptHelperMode.REALTIME\n * });\n *\n * // Subscribe to a channel\n * api.subscribeMessage('channel-id');\n * ```\n *\n * @example\n * Event handling with EventHelper methods:\n * ```typescript\n * const conversationalAIAPI = ConversationalAIAPI.getInstance();\n *\n * // Subscribe to all events using on() method\n * conversationalAIAPI.on(EConversationalAIAPIEvents.AGENT_STATE_CHANGED, (agentUserId, event) => {\n *   console.log(`Agent ${agentUserId} state changed to:`, event.state);\n * });\n *\n * conversationalAIAPI.on(EConversationalAIAPIEvents.TRANSCRIPT_UPDATED, (transcription) => {\n *   console.log('Transcription updated:', transcription);\n * });\n *\n * conversationalAIAPI.on(EConversationalAIAPIEvents.AGENT_INTERRUPTED, (agentUserId, event) => {\n *   console.log(`Agent ${agentUserId} interrupted:`, event);\n * });\n *\n * conversationalAIAPI.on(EConversationalAIAPIEvents.AGENT_METRICS, (agentUserId, metrics) => {\n *   console.log(`Agent ${agentUserId} metrics:`, metrics);\n * });\n *\n * conversationalAIAPI.on(EConversationalAIAPIEvents.AGENT_ERROR, (agentUserId, error) => {\n *   console.error(`Agent ${agentUserId} error:`, error.message);\n * });\n *\n * conversationalAIAPI.on(EConversationalAIAPIEvents.DEBUG_LOG, (message) => {\n *   console.debug('Debug log:', message);\n * });\n *\n * conversationalAIAPI.on(EConversationalAIAPIEvents.MESSAGE_RECEIPT_UPDATED, (agentUserId, messageReceipt) => {\n *  console.log(`Message receipt updated for agent ${agentUserId}:`, messageReceipt);\n * });\n *\n * conversationalAIAPI.on(EConversationalAIAPIEvents.MESSAGE_ERROR, (agentUserId, error) => {\n *  console.error(`Message error for agent ${agentUserId}:`, error);\n * });\n *\n * // Unsubscribe from events using off() method\n * conversationalAIAPI.off(EConversationalAIAPIEvents.AGENT_STATE_CHANGED, handleAgentStateChanged);\n * conversationalAIAPI.off(EConversationalAIAPIEvents.TRANSCRIPT_UPDATED, handleTranscriptionUpdated);\n * conversationalAIAPI.off(EConversationalAIAPIEvents.AGENT_INTERRUPTED, handleAgentInterrupted);\n * conversationalAIAPI.off(EConversationalAIAPIEvents.AGENT_METRICS, handleAgentMetrics);\n * conversationalAIAPI.off(EConversationalAIAPIEvents.AGENT_ERROR, handleAgentError);\n * conversationalAIAPI.off(EConversationalAIAPIEvents.DEBUG_LOG, handleDebugLog);\n * conversationalAIAPI.off(EConversationalAIAPIEvents.MESSAGE_RECEIPT_UPDATED, handleMessageReceiptUpdated);\n * conversationalAIAPI.off(EConversationalAIAPIEvents.MESSAGE_ERROR, handleMessageError);\n * ```\n *\n * @fires {@link EConversationalAIAPIEvents.TRANSCRIPT_UPDATED} When chat history is updated\n * @fires {@link EConversationalAIAPIEvents.AGENT_STATE_CHANGED} When agent state changes\n * @fires {@link EConversationalAIAPIEvents.AGENT_INTERRUPTED} When agent is interrupted\n * @fires {@link EConversationalAIAPIEvents.AGENT_METRICS} When agent metrics are received\n * @fires {@link EConversationalAIAPIEvents.AGENT_ERROR} When an error occurs\n * @fires {@link EConversationalAIAPIEvents.DEBUG_LOG} When debug logs are generated\n * @fires {@link EConversationalAIAPIEvents.MESSAGE_RECEIPT_UPDATED} When message receipt is updated\n * @fires {@link EConversationalAIAPIEvents.MESSAGE_ERROR} When message error occurs\n *\n * @since 1.7.0\n */\nexport class ConversationalAIAPI extends EventHelper<IConversationalAIAPIEventHandlers> {\n  private static NAME = TAG\n  private static VERSION = VERSION\n  private static _instance: ConversationalAIAPI | null = null\n  private callMessagePrint: (type: ELoggerType, ...args: unknown[]) => void\n\n  protected rtcEngine: IAgoraRTCClient | null = null\n  protected rtmEngine: RTMClient | null = null\n  protected renderMode: ETranscriptHelperMode = ETranscriptHelperMode.UNKNOWN\n  protected channel: string | null = null\n  protected covSubRenderController: CovSubRenderController\n  protected enableLog: boolean = false\n\n  constructor() {\n    super()\n\n    this.callMessagePrint = (\n      type: ELoggerType = ELoggerType.debug,\n      ...args: unknown[]\n    ) => {\n      if (!this.enableLog) {\n        return\n      }\n      logger[type](formatLog(...args))\n      this.onDebugLog?.(`[${type}] ${formatLog(...args)}`)\n      agoraLogger[type](...args)\n    }\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `${ConversationalAIAPI.NAME} initialized, version: ${ConversationalAIAPI.VERSION}`\n    )\n\n    this.covSubRenderController = new CovSubRenderController({\n      onChatHistoryUpdated: this.onChatHistoryUpdated.bind(this),\n      onAgentStateChanged: this.onAgentStateChanged.bind(this),\n      onAgentInterrupted: this.onAgentInterrupted.bind(this),\n      onDebugLog: this.onDebugLog.bind(this),\n      onAgentMetrics: this.onAgentMetrics.bind(this),\n      onAgentError: this.onAgentError.bind(this),\n      onMessageReceipt: this.onMessageReceiptUpdated.bind(this),\n      onMessageError: this.onMessageError.bind(this),\n      onMessageSalStatus: this.onMessageSalStatus.bind(this)\n    })\n  }\n\n  /**\n   * Gets the singleton instance of ConversationalAIAPI.\n   *\n   * Retrieves the singleton instance of the ConversationalAIAPI class. This method\n   * ensures that only one instance of ConversationalAIAPI exists throughout the\n   * application lifecycle.\n   *\n   * @remarks\n   * - Must call {@link init} before using this method\n   * - Throws error if instance is not initialized\n   *\n   * @returns The singleton instance of ConversationalAIAPI\n   * @throws {@link NotFoundError} When ConversationalAIAPI is not initialized\n   * @since 1.6.0\n   */\n  public static getInstance() {\n    if (!ConversationalAIAPI._instance) {\n      throw new NotFoundError('ConversationalAIAPI is not initialized')\n    }\n    return ConversationalAIAPI._instance\n  }\n\n  public getCfg() {\n    if (!this.rtcEngine || !this.rtmEngine) {\n      throw new NotFoundError('ConversationalAIAPI is not initialized')\n    }\n    return {\n      rtcEngine: this.rtcEngine,\n      rtmEngine: this.rtmEngine,\n      renderMode: this.renderMode,\n      channel: this.channel,\n      enableLog: this.enableLog\n    }\n  }\n\n  /**\n   * Initializes the ConversationalAIAPI singleton instance.\n   *\n   * This method sets up the RTC and RTM engines, render mode, and logging options.\n   * It must be called before any other methods of ConversationalAIAPI can be used.\n   *\n   * @remarks\n   * - Only one instance can be initialized at a time\n   * - Throws error if already initialized\n   *\n   * @param cfg - Configuration object for initializing the API\n   * @returns The initialized instance of ConversationalAIAPI\n   * @throws {@link Error} If ConversationalAIAPI is already initialized\n   * @since 1.6.0\n   */\n  public static init(cfg: IConversationalAIAPIConfig) {\n    if (!ConversationalAIAPI._instance) {\n      ConversationalAIAPI._instance = new ConversationalAIAPI()\n    }\n    ConversationalAIAPI._instance.rtcEngine = cfg.rtcEngine\n    ConversationalAIAPI._instance.rtmEngine = cfg.rtmEngine\n    ConversationalAIAPI._instance.renderMode =\n      cfg.renderMode ?? ETranscriptHelperMode.UNKNOWN\n    ConversationalAIAPI._instance.enableLog = cfg.enableLog ?? false\n\n    return ConversationalAIAPI._instance\n  }\n\n  /**\n   * Subscribes to a message channel for real-time updates.\n   *\n   * This method binds the necessary RTC and RTM events, sets the channel,\n   * and starts the CovSubRenderController to handle incoming messages.\n   *\n   * @remarks\n   * - Must call {@link init} before using this method\n   * - Throws error if not initialized\n   *\n   * @param channel - The channel to subscribe to for messages\n   * @since 1.6.0\n   */\n  public subscribeMessage(channel: string) {\n    this.bindRtcEvents()\n    this.bindRtmEvents()\n\n    this.channel = channel\n    this.covSubRenderController.setMode(this.renderMode)\n    this.covSubRenderController.run()\n  }\n\n  /**\n   * Unsubscribes from the message channel and cleans up resources.\n   *\n   * This method unbinds the RTC and RTM events, clears the channel,\n   * and cleans up the CovSubRenderController.\n   *\n   * @remarks\n   * - Must call {@link subscribeMessage} before using this method\n   * - Throws error if not initialized\n   *\n   * @since 1.6.0\n   */\n  public unsubscribe() {\n    this.unbindRtcEvents()\n    this.unbindRtmEvents()\n\n    this.channel = null\n    this.covSubRenderController.cleanup()\n  }\n\n  /**\n   * Destroys the ConversationalAIAPI instance and cleans up resources.\n   *\n   * This method unbinds all RTC and RTM events, clears the channel,\n   * and cleans up the CovSubRenderController.\n   *\n   * @remarks\n   * - Must call {@link unsubscribe} before using this method\n   * - Throws error if not initialized\n   *\n   * @since 1.6.0\n   */\n  public destroy() {\n    const instance = ConversationalAIAPI.getInstance()\n    if (instance) {\n      instance?.rtcEngine?.removeAllListeners()\n      instance.rtcEngine = null\n      instance?.rtmEngine?.removeAllListeners()\n      instance.rtmEngine = null\n      instance.renderMode = ETranscriptHelperMode.UNKNOWN\n      instance.channel = null\n      instance.removeAllEventListeners()\n      ConversationalAIAPI._instance = null\n    }\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `${ConversationalAIAPI.NAME} destroyed`\n    )\n  }\n\n  /**\n   * Sends a chat message to the conversational AI agent.\n   *\n   * @param agentUserId - The unique identifier of the agent user\n   * @param message - The chat message to send, can be either text or image type\n   * @returns A promise that resolves with the result of sending the message\n   * @throws {Error} When an unsupported chat message type is provided\n   *\n   * @since 1.7.0\n   *\n   * @example\n   * ```typescript\n   * // Send a text message\n   * const textMessage: IChatMessageText = {\n   *   messageType: EChatMessageType.TEXT,\n   *   priority: EChatMessagePriority.HIGH,\n   *   responseInterruptable: true,\n   *   text: \"Hello, how are you?\"\n   * };\n   * await api.chat(\"user123\", textMessage);\n   *\n   * // Send an image message\n   * const imageMessage: IChatMessageImage = {\n   *   messageType: EChatMessageType.IMAGE,\n   *   uuid: \"msg-456\",\n   *   url: \"https://example.com/image.jpg\"\n   * };\n   * await api.chat(\"user123\", imageMessage);\n   * ```\n   */\n  public async chat(\n    agentUserId: string,\n    message: IChatMessageText | IChatMessageImage\n  ) {\n    switch (message.messageType) {\n      case EChatMessageType.TEXT:\n        return this.sendText(agentUserId, message as IChatMessageText)\n      case EChatMessageType.IMAGE:\n        return this.sendImage(agentUserId, message as IChatMessageImage)\n      default:\n        throw new Error('Unsupported chat message type')\n    }\n  }\n\n  /**\n   * Sends a text message to the specified agent user through RTM engine.\n   *\n   * @param agentUserId - The unique identifier of the agent user to send the message to\n   * @param message - The chat message object containing text content and optional settings\n   * @param message.priority - Optional priority level for the message (defaults to INTERRUPTED)\n   * @param message.responseInterruptable - Optional flag indicating if the response can be interrupted (defaults to true)\n   * @param message.text - The actual text content of the message\n   *\n   * @returns Promise that resolves when the message is successfully sent\n   *\n   * @throws {Error} Throws an error with message \"failed to send chat message\" if the RTM publish operation fails\n   *\n   * @since 1.7.0\n   *\n   * @example\n   * ```typescript\n   * await api.sendText('user123', {\n   *   text: 'Hello, how can I help you?',\n   *   priority: EChatMessagePriority.HIGH,\n   *   responseInterruptable: false\n   * });\n   * ```\n   */\n  public async sendText(agentUserId: string, message: IChatMessageText) {\n    const traceId = genTranceID()\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `>>> [trancID:${traceId}] [chat] ${agentUserId}`,\n      message\n    )\n\n    const { rtmEngine } = this.getCfg()\n\n    const payload = {\n      priority: message.priority ?? EChatMessagePriority.INTERRUPTED,\n      interruptable: message.responseInterruptable ?? true,\n      message: message.text ?? ''\n    }\n\n    try {\n      const payloadStr = JSON.stringify(payload)\n      const options = {\n        channelType: 'USER' as ChannelType,\n        customType: EMessageType.USER_TRANSCRIPTION\n      }\n\n      this.callMessagePrint(\n        ELoggerType.debug,\n        `msg: [traceID: ${traceId}] rtm publish`,\n        payloadStr\n      )\n\n      const result = await rtmEngine.publish(agentUserId, payloadStr, options)\n\n      this.callMessagePrint(\n        ELoggerType.debug,\n        `>>> [trancID:${traceId}] [chat]`,\n        'sucessfully sent chat message',\n        result\n      )\n    } catch (error: unknown) {\n      this.callMessagePrint(\n        ELoggerType.error,\n        `>>> [trancID:${traceId}] [chat]`,\n        'failed to send chat message',\n        error\n      )\n      throw new Error('failed to send chat message')\n    }\n  }\n\n  /**\n   * Sends an image message to a specific agent user through RTM (Real-Time Messaging).\n   *\n   * @param agentUserId - The unique identifier of the agent user to send the image to\n   * @param message - The image message object containing UUID and either URL or base64 data\n   * @param message.uuid - Unique identifier for the message\n   * @param message.url - Optional URL of the image to send\n   * @param message.base64 - Optional base64 encoded image data\n   *\n   * @throws {Error} Throws an error with message \"failed to send chat message\" if the RTM publish operation fails\n   *\n   * @returns Promise that resolves when the image message is successfully sent\n   *\n   * @since 1.7.0\n   *\n   * @example\n   * ```typescript\n   * await sendImage('user123', {\n   *   uuid: 'msg-456',\n   *   url: 'https://example.com/image.jpg'\n   * });\n   * ```\n   */\n  public async sendImage(agentUserId: string, message: IChatMessageImage) {\n    const traceId = genTranceID()\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `>>> [trancID:${traceId}] [chat] ${agentUserId}`,\n      message\n    )\n\n    const { rtmEngine } = this.getCfg()\n\n    const payload = {\n      uuid: message.uuid,\n      image_url: message?.url || '',\n      image_base64: message?.base64 || ''\n    }\n\n    try {\n      const payloadStr = JSON.stringify(payload)\n      const options = {\n        channelType: 'USER' as ChannelType,\n        customType: EMessageType.IMAGE_UPLOAD\n      }\n\n      this.callMessagePrint(\n        ELoggerType.debug,\n        `msg: [traceID: ${traceId}] rtm publish`,\n        payloadStr\n      )\n\n      const result = await rtmEngine.publish(agentUserId, payloadStr, options)\n\n      this.callMessagePrint(\n        ELoggerType.debug,\n        `>>> [trancID:${traceId}] [chat]`,\n        'sucessfully sent chat message',\n        result\n      )\n    } catch (error: unknown) {\n      this.callMessagePrint(\n        ELoggerType.error,\n        `>>> [trancID:${traceId}] [chat]`,\n        'failed to send chat message',\n        error\n      )\n      throw new Error('failed to send chat message')\n    }\n  }\n\n  /**\n   * Sends an interrupt message to the specified agent user.\n   *\n   * This method publishes an interrupt message to the RTM channel of the specified agent user.\n   * It is used to signal that the current interaction should be interrupted.\n   *\n   * @remarks\n   * - Must call {@link init} before using this method\n   * - Throws error if not initialized or if sending fails\n   *\n   * @param agentUserId - The user ID of the agent to interrupt\n   * @since 1.6.0\n   */\n  public async interrupt(agentUserId: string) {\n    const traceId = genTranceID()\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `>>> [trancID:${traceId}] [interrupt]`,\n      agentUserId\n    )\n\n    const { rtmEngine } = this.getCfg()\n\n    const options = {\n      channelType: 'USER' as ChannelType,\n      customType: EMessageType.MSG_INTERRUPTED\n    }\n    const messageStr = JSON.stringify({\n      customType: EMessageType.MSG_INTERRUPTED\n    })\n\n    try {\n      const result = await rtmEngine.publish(agentUserId, messageStr, options)\n      this.callMessagePrint(\n        ELoggerType.debug,\n        `>>> [trancID:${traceId}] [interrupt]`,\n        'sucessfully sent interrupt message',\n        result\n      )\n    } catch (error: unknown) {\n      this.callMessagePrint(\n        ELoggerType.error,\n        `>>> [trancID:${traceId}] [interrupt]`,\n        'failed to send interrupt message',\n        error\n      )\n      throw new Error('failed to send interrupt message')\n    }\n  }\n\n  private onChatHistoryUpdated(\n    chatHistory: ITranscriptHelperItem<\n      Partial<IUserTranscription | IAgentTranscription>\n    >[]\n  ) {\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `>>> ${EConversationalAIAPIEvents.TRANSCRIPT_UPDATED}`,\n      chatHistory\n    )\n    this.emit(EConversationalAIAPIEvents.TRANSCRIPT_UPDATED, chatHistory)\n  }\n  private onAgentStateChanged(agentUserId: string, event: TStateChangeEvent) {\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `>>> ${EConversationalAIAPIEvents.AGENT_STATE_CHANGED}`,\n      agentUserId,\n      event\n    )\n    this.emit(\n      EConversationalAIAPIEvents.AGENT_STATE_CHANGED,\n      agentUserId,\n      event\n    )\n  }\n  private onAgentInterrupted(\n    agentUserId: string,\n    event: { turnID: number; timestamp: number }\n  ) {\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `>>> ${EConversationalAIAPIEvents.AGENT_INTERRUPTED}`,\n      agentUserId,\n      event\n    )\n    this.emit(EConversationalAIAPIEvents.AGENT_INTERRUPTED, agentUserId, event)\n  }\n  private onDebugLog(message: string) {\n    this.emit(EConversationalAIAPIEvents.DEBUG_LOG, message)\n  }\n  private onAgentMetrics(agentUserId: string, metrics: TAgentMetric) {\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `>>> ${EConversationalAIAPIEvents.AGENT_METRICS}`,\n      agentUserId,\n      metrics\n    )\n    this.emit(EConversationalAIAPIEvents.AGENT_METRICS, agentUserId, metrics)\n  }\n  private onAgentError(agentUserId: string, error: TModuleError) {\n    this.callMessagePrint(\n      ELoggerType.error,\n      `>>> ${EConversationalAIAPIEvents.AGENT_ERROR}`,\n      agentUserId,\n      error\n    )\n    this.emit(EConversationalAIAPIEvents.AGENT_ERROR, agentUserId, error)\n  }\n  private onMessageReceiptUpdated(\n    agentUserId: string,\n    messageReceipt: TMessageReceipt\n  ) {\n    this.callMessagePrint(\n      ELoggerType.error,\n      `>>> ${EConversationalAIAPIEvents.MESSAGE_RECEIPT_UPDATED}`,\n      agentUserId,\n      messageReceipt\n    )\n    this.emit(\n      EConversationalAIAPIEvents.MESSAGE_RECEIPT_UPDATED,\n      agentUserId,\n      messageReceipt\n    )\n  }\n  private onMessageError(\n    agentUserId: string,\n    error: {\n      type: EChatMessageType\n      code: number\n      message: string\n      timestamp: number\n    }\n  ) {\n    this.callMessagePrint(\n      ELoggerType.error,\n      `>>> ${EConversationalAIAPIEvents.MESSAGE_ERROR}`,\n      agentUserId,\n      error\n    )\n    this.emit(EConversationalAIAPIEvents.MESSAGE_ERROR, agentUserId, error)\n  }\n\n  private onMessageSalStatus(agentUserId: string, message: IMessageSalStatus) {\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `>>> ${EConversationalAIAPIEvents.MESSAGE_SAL_STATUS}`,\n      agentUserId,\n      message\n    )\n    this.emit(\n      EConversationalAIAPIEvents.MESSAGE_SAL_STATUS,\n      agentUserId,\n      message\n    )\n  }\n\n  private bindRtcEvents() {\n    // this.getCfg().rtcEngine.on(\n    //   ERTCEvents.AUDIO_METADATA,\n    //   this._handleRtcAudioMetadata.bind(this)\n    // )\n    this.getCfg().rtcEngine.on(\n      ERTCEvents.AUDIO_PTS,\n      this._handleRtcAudioPTS.bind(this)\n    )\n  }\n  private unbindRtcEvents() {\n    // this.getCfg().rtcEngine.off(\n    //   ERTCEvents.AUDIO_METADATA,\n    //   this._handleRtcAudioMetadata.bind(this)\n    // )\n    this.getCfg().rtcEngine.off(\n      ERTCEvents.AUDIO_PTS,\n      this._handleRtcAudioPTS.bind(this)\n    )\n  }\n  private bindRtmEvents() {\n    // - message\n    this.getCfg().rtmEngine.addEventListener(\n      ERTMEvents.MESSAGE,\n      this._handleRtmMessage.bind(this)\n    )\n    // - presence\n    this.getCfg().rtmEngine.addEventListener(\n      ERTMEvents.PRESENCE,\n      this._handleRtmPresence.bind(this)\n    )\n    // - status\n    this.getCfg().rtmEngine.addEventListener(\n      ERTMEvents.STATUS,\n      this._handleRtmStatus.bind(this)\n    )\n  }\n  private unbindRtmEvents() {\n    // - message\n    this.getCfg().rtmEngine.removeEventListener(\n      ERTMEvents.MESSAGE,\n      this._handleRtmMessage.bind(this)\n    )\n    // - presence\n    this.getCfg().rtmEngine.removeEventListener(\n      ERTMEvents.PRESENCE,\n      this._handleRtmPresence.bind(this)\n    )\n    // - status\n    this.getCfg().rtmEngine.removeEventListener(\n      ERTMEvents.STATUS,\n      this._handleRtmStatus.bind(this)\n    )\n  }\n\n  // private _handleRtcAudioMetadata(metadata: Uint8Array) {\n  //   try {\n  //     const pts64 = Number(new DataView(metadata.buffer).getBigUint64(0, true))\n  //     this.callMessagePrint(\n  //       ELoggerType.debug,\n  //       `<<< ${ERTCEvents.AUDIO_METADATA}`,\n  //       pts64\n  //     )\n  //     this.covSubRenderController.setPts(pts64)\n  //   } catch (error) {\n  //     this.callMessagePrint(\n  //       ELoggerType.error,\n  //       `<<< ${ERTCEvents.AUDIO_METADATA}`,\n  //       metadata,\n  //       error\n  //     )\n  //   }\n  // }\n\n  private _handleRtcAudioPTS(pts: number) {\n    try {\n      this.callMessagePrint(\n        ELoggerType.debug,\n        `<<< ${ERTCEvents.AUDIO_PTS}`,\n        pts\n      )\n      this.covSubRenderController.setPts(pts)\n    } catch (error) {\n      this.callMessagePrint(\n        ELoggerType.error,\n        `<<< ${ERTCEvents.AUDIO_PTS}`,\n        pts,\n        error\n      )\n    }\n  }\n\n  private _handleRtmMessage(message: RTMEvents.MessageEvent) {\n    const traceId = genTranceID()\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `>>> [trancID:${traceId}] ${ERTMEvents.MESSAGE}`,\n      `Publisher: ${message.publisher}, type: ${message.messageType}`\n    )\n    // Handle the message\n    try {\n      const messageData = message.message\n      // if string, parse it\n      if (typeof messageData === 'string') {\n        const parsedMessage = JSON.parse(messageData)\n        this.callMessagePrint(\n          ELoggerType.debug,\n          `>>> [trancID:${traceId}] ${ERTMEvents.MESSAGE}`,\n          parsedMessage\n        )\n        this.covSubRenderController.handleMessage(parsedMessage, {\n          publisher: message.publisher\n        })\n        return\n      }\n      // if Uint8Array, convert to string\n      if (messageData instanceof Uint8Array) {\n        const decoder = new TextDecoder('utf-8')\n        const messageString = decoder.decode(messageData)\n        const parsedMessage = JSON.parse(messageString)\n        this.callMessagePrint(\n          ELoggerType.debug,\n          `>>> [trancID:${traceId}] ${ERTMEvents.MESSAGE}`,\n          parsedMessage\n        )\n        this.covSubRenderController.handleMessage(parsedMessage, {\n          publisher: message.publisher\n        })\n        return\n      }\n      this.callMessagePrint(\n        ELoggerType.warn,\n        `>>> [trancID:${traceId}] ${ERTMEvents.MESSAGE}`,\n        'Unsupported message type received'\n      )\n    } catch (error) {\n      this.callMessagePrint(\n        ELoggerType.error,\n        `>>> [trancID:${traceId}] ${ERTMEvents.MESSAGE}`,\n        'Failed to parse message',\n        error\n      )\n    }\n  }\n  private _handleRtmPresence(presence: RTMEvents.PresenceEvent) {\n    const traceId = genTranceID()\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `>>> [trancID:${traceId}] ${ERTMEvents.PRESENCE}`,\n      `Publisher: ${presence.publisher}`\n    )\n    // Handle the presence event\n    const stateChanged = presence.stateChanged\n    if (stateChanged?.state && stateChanged?.turn_id) {\n      this.callMessagePrint(\n        ELoggerType.debug,\n        `>>> [trancID:${traceId}] ${ERTMEvents.PRESENCE}`,\n        `State changed: ${stateChanged.state}, Turn ID: ${stateChanged.turn_id}, timestamp: ${presence.timestamp}`\n      )\n      this.covSubRenderController.handleAgentStatus(\n        presence as Omit<RTMEvents.PresenceEvent, 'stateChanged'> & {\n          stateChanged: {\n            state: EAgentState\n            turn_id: string\n          }\n        }\n      )\n    }\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `>>> [trancID:${traceId}] ${ERTMEvents.PRESENCE}`,\n      'No state change detected, skipping handling presence event'\n    )\n  }\n  private _handleRtmStatus(\n    status:\n      | RTMEvents.RTMConnectionStatusChangeEvent\n      | RTMEvents.StreamChannelConnectionStatusChangeEvent\n  ) {\n    const traceId = genTranceID()\n    this.callMessagePrint(\n      ELoggerType.debug,\n      `>>> [trancID:${traceId}] ${ERTMEvents.STATUS}`,\n      status\n    )\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1788, "column": 0}, "map": {"version":3,"sources":["file:///Users/jalbo/Desktop/dev/blog/convoAI_ecommerce/components/ChatInterface.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useRef, useEffect } from \"react\";\nimport { useAgora } from \"@/hooks/useAgora\";\nimport { ConversationalAIAPI } from \"@/lib/conversational-ai-api\";\nimport {\n  EConversationalAIAPIEvents,\n  ETranscriptHelperMode,\n  EChatMessagePriority,\n  EChatMessageType,\n  type ITranscriptHelperItem,\n  type IChatMessageText,\n} from \"@/lib/conversational-ai-api/type\";\n\ninterface Product {\n  id: string;\n  name: string;\n}\n\ninterface ChatMessage {\n  role: \"user\" | \"assistant\";\n  content: string;\n  uid?: string;\n}\n\ninterface ChatInterfaceProps {\n  product: Product;\n  onClose: () => void;\n}\n\nexport function ChatInterface({ product, onClose }: ChatInterfaceProps) {\n  const [messages, setMessages] = useState<ChatMessage[]>([]);\n  const [input, setInput] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [isInitializing, setIsInitializing] = useState(true);\n  const [agoraConfig, setAgoraConfig] = useState<{\n    appId: string;\n    channel: string;\n    token: string;\n    uid: number;\n    rtmUserId: string;\n  } | null>(null);\n  const [agentId, setAgentId] = useState<string | null>(null);\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  const isInitializingRef = useRef(false);\n  const rtmClientRef = useRef<any>(null);\n  const convoApiRef = useRef<ConversationalAIAPI | null>(null);\n\n  // Initialize Agora RTC connection\n  const agora = useAgora(\n    agoraConfig\n      ? {\n          appId: agoraConfig.appId,\n          channel: agoraConfig.channel,\n          token: agoraConfig.token,\n          uid: agoraConfig.uid,\n        }\n      : {\n          appId: \"\",\n          channel: \"\",\n          token: \"\",\n          uid: 0,\n        }\n  );\n\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  }, [messages]);\n\n  // Initialize Agora session on mount\n  useEffect(() => {\n    const initializeAgora = async () => {\n      if (isInitializingRef.current) return;\n      isInitializingRef.current = true;\n      try {\n        // Initialize Agora session\n        const initRes = await fetch(\"/api/agora/initialize\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({\n            userId: Math.floor(Math.random() * 100000),\n          }),\n        });\n\n        const initData = await initRes.json();\n        setAgoraConfig({\n          appId: initData.appId,\n          channel: initData.channel,\n          token: initData.token,\n          uid: initData.uid,\n          rtmUserId: initData.rtmUserId || initData.uid.toString(),\n        });\n\n        // Start AI agent\n        const agentRes = await fetch(\"/api/agora/start-agent\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({\n            channel: initData.channel,\n            userId: initData.uid,\n            token: initData.token,\n          }),\n        });\n\n        if (!agentRes.ok) {\n          const errorData = await agentRes.json();\n          throw new Error(\n            errorData.error || `Failed to start agent: ${agentRes.status}`\n          );\n        }\n\n        const agentData = await agentRes.json();\n\n        if (agentData.agent_id) {\n          setAgentId(agentData.agent_id);\n        }\n\n        // Set greeting message from ConvoAI if available\n        if (agentData.greeting_message) {\n          setMessages([\n            {\n              role: \"assistant\",\n              content: agentData.greeting_message,\n            },\n          ]);\n        } else if (agentData.properties?.llm?.greeting_message) {\n          setMessages([\n            {\n              role: \"assistant\",\n              content: agentData.properties.llm.greeting_message,\n            },\n          ]);\n        }\n\n        setIsInitializing(false);\n      } catch (error) {\n        console.error(\"Failed to initialize Agora:\", error);\n        setIsInitializing(false);\n      }\n    };\n\n    initializeAgora();\n  }, [product.id]);\n\n  // Initialize RTM and ConversationalAIAPI toolkit\n  useEffect(() => {\n    if (\n      !agoraConfig ||\n      !agora?.client ||\n      typeof window === \"undefined\" ||\n      convoApiRef.current\n    ) {\n      return;\n    }\n\n    let isMounted = true;\n\n    const initToolkit = async () => {\n      try {\n        // Initialize RTM client\n        const AgoraRTM = await import(\"agora-rtm-sdk\");\n        const RTM =\n          (AgoraRTM.default as any)?.RTM ||\n          (AgoraRTM as any).RTM ||\n          AgoraRTM.default;\n\n        if (!RTM || typeof RTM !== \"function\") {\n          throw new Error(\"Failed to get RTM class\");\n        }\n\n        const rtmClient = new RTM(agoraConfig.appId, agoraConfig.rtmUserId);\n        rtmClientRef.current = rtmClient;\n\n        await rtmClient.login({ token: agoraConfig.token });\n\n        if (!isMounted) {\n          await rtmClient.logout().catch(() => {});\n          return;\n        }\n\n        // Initialize ConversationalAIAPI toolkit\n        const convoAPI = ConversationalAIAPI.init({\n          rtcEngine: agora.client!,\n          rtmEngine: rtmClient as any,\n          renderMode: ETranscriptHelperMode.TEXT,\n          enableLog: false,\n        });\n\n        convoApiRef.current = convoAPI;\n\n        // Subscribe to channel messages (required before agent starts)\n        convoAPI.subscribeMessage(agoraConfig.channel);\n\n        // Listen for transcript updates (both user and agent)\n        (convoAPI as any).on(\n          EConversationalAIAPIEvents.TRANSCRIPT_UPDATED,\n          (transcripts: ITranscriptHelperItem<any>[]) => {\n            if (!isMounted) return;\n\n            // Convert transcripts to chat messages\n            const newMessages: ChatMessage[] = transcripts.map((item) => {\n              // Determine if it's from agent (uid \"1000\") or user\n              const isAgent = item.uid === \"1000\";\n              return {\n                role: isAgent ? \"assistant\" : \"user\",\n                content: item.text || \"\",\n                uid: item.uid,\n              };\n            });\n\n            // Update messages, removing duplicates by uid and turn_id\n            setMessages((prev) => {\n              const existing = new Map<string, ChatMessage>();\n              prev.forEach((msg) => {\n                const key = `${msg.uid || msg.role}-${msg.content}`;\n                existing.set(key, msg);\n              });\n\n              newMessages.forEach((msg) => {\n                const key = `${msg.uid || msg.role}-${msg.content}`;\n                if (!existing.has(key) && msg.content.trim()) {\n                  existing.set(key, msg);\n                }\n              });\n\n              return Array.from(existing.values());\n            });\n          }\n        );\n      } catch (error) {\n        console.error(\"Toolkit init error:\", error);\n      }\n    };\n\n    initToolkit();\n\n    return () => {\n      isMounted = false;\n      if (convoApiRef.current) {\n        try {\n          convoApiRef.current.unsubscribe();\n          convoApiRef.current.destroy();\n        } catch (e) {\n          // Ignore cleanup errors\n        }\n        convoApiRef.current = null;\n      }\n      if (rtmClientRef.current) {\n        rtmClientRef.current.logout().catch(() => {});\n        rtmClientRef.current = null;\n      }\n    };\n  }, [agoraConfig, agora?.client]);\n\n  const sendMessage = async () => {\n    if (!input.trim() || isLoading || !convoApiRef.current || !agentId) return;\n\n    const userMessage = input;\n    setInput(\"\");\n    setIsLoading(true);\n\n    try {\n      // Use toolkit's sendText method\n      const message: IChatMessageText = {\n        messageType: EChatMessageType.TEXT,\n        text: userMessage,\n        priority: EChatMessagePriority.INTERRUPTED,\n        responseInterruptable: true,\n      };\n      await convoApiRef.current.sendText(\"1000\", message);\n      setIsLoading(false);\n    } catch (error: any) {\n      console.error(\"Chat error:\", error);\n      setMessages((prev) => [\n        ...prev,\n        {\n          role: \"assistant\",\n          content: \"Sorry, I encountered an error. Please try again.\",\n        },\n      ]);\n      setIsLoading(false);\n    }\n  };\n\n  const handleKeyPress = (e: React.KeyboardEvent) => {\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      e.preventDefault();\n      sendMessage();\n    }\n  };\n\n  const handleEndCall = () => {\n    if (agora) {\n      agora.leave();\n    }\n    if (convoApiRef.current) {\n      try {\n        convoApiRef.current.unsubscribe();\n        convoApiRef.current.destroy();\n      } catch (e) {\n        // Ignore cleanup errors\n      }\n      convoApiRef.current = null;\n    }\n    if (rtmClientRef.current) {\n      rtmClientRef.current.logout().catch(() => {});\n      rtmClientRef.current = null;\n    }\n    onClose();\n  };\n\n  const handleClose = () => {\n    handleEndCall();\n  };\n\n  const handleToggleMute = () => {\n    if (agora) {\n      agora.toggleMute();\n    }\n  };\n\n  return (\n    <div className=\"fixed bottom-24 right-6 z-50 w-80\">\n      <div className=\"bg-white rounded-lg shadow-2xl border border-gray-200 h-[500px] flex flex-col\">\n        {/* Header */}\n        <div className=\"flex items-center justify-between p-3 border-b bg-gradient-to-r from-blue-600 to-blue-700 text-white rounded-t-lg\">\n          <div className=\"flex items-center gap-2\">\n            <div className=\"relative\">\n              <svg className=\"w-4 h-4\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path d=\"M12 2a3 3 0 0 0-3 3v6a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3z\" />\n                <path d=\"M19 10v1a7 7 0 0 1-14 0v-1M12 18v4M8 22h8\" />\n              </svg>\n              {agora?.isConnected && (\n                <div className=\"absolute -top-1 -right-1 w-2 h-2 bg-green-400 rounded-full animate-pulse\"></div>\n              )}\n            </div>\n            <div>\n              <h3 className=\"text-sm font-semibold\">Voice Assistant</h3>\n              {isInitializing ? (\n                <span className=\"text-xs text-blue-200\">Connecting...</span>\n              ) : agora?.isConnected ? (\n                <span className=\"text-xs text-green-200\">Listening...</span>\n              ) : (\n                <span className=\"text-xs text-blue-200\">Ready</span>\n              )}\n            </div>\n          </div>\n          <button\n            onClick={handleClose}\n            className=\"text-white hover:text-gray-200 transition\"\n            aria-label=\"Close\"\n          >\n            <svg\n              className=\"w-6 h-6\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n            >\n              <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth={2}\n                d=\"M6 18L18 6M6 6l12 12\"\n              />\n            </svg>\n          </button>\n        </div>\n\n        {/* Messages */}\n        <div className=\"flex-1 overflow-y-auto p-3 space-y-2 bg-gray-50 text-sm\">\n          {messages.map((msg, idx) => (\n            <div\n              key={idx}\n              className={`flex ${\n                msg.role === \"user\" ? \"justify-end\" : \"justify-start\"\n              }`}\n            >\n              <div\n                className={`max-w-[85%] rounded-lg p-2 ${\n                  msg.role === \"user\"\n                    ? \"bg-blue-600 text-white\"\n                    : \"bg-white text-gray-800 shadow-sm\"\n                }`}\n              >\n                <p className=\"text-xs leading-relaxed\">{msg.content}</p>\n              </div>\n            </div>\n          ))}\n          {isLoading && (\n            <div className=\"flex justify-start\">\n              <div className=\"bg-white text-gray-800 rounded-lg p-2 shadow-sm\">\n                <div className=\"flex gap-1\">\n                  <div className=\"w-1.5 h-1.5 bg-gray-400 rounded-full animate-bounce\"></div>\n                  <div\n                    className=\"w-1.5 h-1.5 bg-gray-400 rounded-full animate-bounce\"\n                    style={{ animationDelay: \"0.1s\" }}\n                  ></div>\n                  <div\n                    className=\"w-1.5 h-1.5 bg-gray-400 rounded-full animate-bounce\"\n                    style={{ animationDelay: \"0.2s\" }}\n                  ></div>\n                </div>\n              </div>\n            </div>\n          )}\n          <div ref={messagesEndRef} />\n        </div>\n\n        {/* Input Area - Voice First, Text as Alternative */}\n        <div className=\"p-3 border-t bg-white rounded-b-lg\">\n          {/* Primary: Voice Control - Mute/Unmute */}\n          <div className=\"mb-2 flex gap-2\">\n            <button\n              onClick={handleToggleMute}\n              disabled={!agora?.isConnected || isInitializing}\n              className={`flex-1 py-2 px-2 rounded-lg transition font-medium flex items-center justify-center gap-1 text-xs min-w-0 ${\n                agora?.isMuted\n                  ? \"bg-red-100 text-red-700 hover:bg-red-200 border border-red-300\"\n                  : \"bg-blue-600 text-white hover:bg-blue-700 shadow-md\"\n              } disabled:opacity-50 disabled:cursor-not-allowed`}\n              title={agora?.isMuted ? \"Unmute microphone\" : \"Mute microphone\"}\n              aria-label={agora?.isMuted ? \"Unmute\" : \"Mute\"}\n            >\n              <svg\n                className=\"w-3.5 h-3.5 flex-shrink-0\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                viewBox=\"0 0 24 24\"\n              >\n                {agora?.isMuted ? (\n                  <>\n                    <path\n                      strokeLinecap=\"round\"\n                      strokeLinejoin=\"round\"\n                      strokeWidth={2}\n                      d=\"M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z\"\n                    />\n                    <path\n                      strokeLinecap=\"round\"\n                      strokeLinejoin=\"round\"\n                      strokeWidth={2}\n                      d=\"M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2\"\n                    />\n                  </>\n                ) : (\n                  <path\n                    strokeLinecap=\"round\"\n                    strokeLinejoin=\"round\"\n                    strokeWidth={2}\n                    d=\"M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z\"\n                  />\n                )}\n              </svg>\n              <span className=\"text-xs whitespace-nowrap truncate\">\n                {agora?.isMuted ? \"Unmute\" : \"Mute\"}\n              </span>\n            </button>\n            <button\n              onClick={handleEndCall}\n              disabled={isInitializing}\n              className=\"bg-red-600 hover:bg-red-700 disabled:bg-red-400 disabled:cursor-not-allowed text-white py-2 px-2.5 rounded-lg transition font-medium flex items-center justify-center gap-1 shadow-md text-xs flex-shrink-0\"\n              title=\"End call\"\n              aria-label=\"End call\"\n            >\n              <svg\n                className=\"w-3.5 h-3.5\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                viewBox=\"0 0 24 24\"\n              >\n                <path\n                  strokeLinecap=\"round\"\n                  strokeLinejoin=\"round\"\n                  strokeWidth={2}\n                  d=\"M16 8l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2M16 8l-8 8m0 0l-2-2m2 2l2-2\"\n                />\n              </svg>\n              <span className=\"text-xs whitespace-nowrap\">End</span>\n            </button>\n          </div>\n\n          {/* Secondary: Text Input (Collapsible) */}\n          <details className=\"text-xs\">\n            <summary className=\"cursor-pointer text-gray-500 hover:text-gray-700 mb-1.5\">\n              Or type a message\n            </summary>\n            <div className=\"flex gap-2 mt-2\">\n              <input\n                type=\"text\"\n                value={input}\n                onChange={(e) => setInput(e.target.value)}\n                onKeyPress={handleKeyPress}\n                className=\"flex-1 border border-gray-300 rounded px-2 py-1.5 text-xs focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-transparent disabled:opacity-50\"\n                disabled={isLoading || isInitializing || !convoApiRef.current}\n                placeholder=\"Type your question...\"\n              />\n              <button\n                onClick={sendMessage}\n                disabled={\n                  isLoading ||\n                  !input.trim() ||\n                  isInitializing ||\n                  !convoApiRef.current ||\n                  !agentId\n                }\n                className=\"bg-gray-600 hover:bg-gray-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white px-3 py-1.5 rounded text-xs transition\"\n              >\n                Send\n              </button>\n            </div>\n          </details>\n        </div>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2383, "column": 0}, "map": {"version":3,"sources":["file:///Users/jalbo/Desktop/dev/blog/convoAI_ecommerce/components/AIAssistant.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState } from \"react\";\nimport { ChatInterface } from \"./ChatInterface\";\n\ninterface Product {\n  id: string;\n  name: string;\n  price: number;\n  rating: number;\n  description: string;\n  reviews: any[];\n}\n\ninterface AIAssistantProps {\n  product: Product;\n}\n\nexport function AIAssistant({ product }: AIAssistantProps) {\n  const [isOpen, setIsOpen] = useState(false);\n\n  return (\n    <>\n      {/* Floating Button */}\n      <button\n        onClick={() => setIsOpen(true)}\n        className=\"fixed bottom-6 right-6 bg-blue-600 hover:bg-blue-700 text-white p-4 rounded-full shadow-lg transition hover:scale-110 z-50 flex items-center justify-center group\"\n        aria-label=\"Open AI Voice Assistant\"\n        title=\"Talk to AI Assistant\"\n      >\n        {/* Microphone icon with sound waves */}\n        <div className=\"relative\">\n          <svg\n            className=\"w-6 h-6\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            viewBox=\"0 0 24 24\"\n          >\n            <path\n              strokeLinecap=\"round\"\n              strokeLinejoin=\"round\"\n              strokeWidth={2}\n              d=\"M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z\"\n            />\n          </svg>\n          {/* Animated sound waves */}\n          <div className=\"absolute inset-0 flex items-center justify-center\">\n            <div className=\"absolute w-8 h-8 border-2 border-white rounded-full opacity-0 group-hover:opacity-100 group-hover:animate-ping\"></div>\n            <div\n              className=\"absolute w-10 h-10 border-2 border-white rounded-full opacity-0 group-hover:opacity-50 group-hover:animate-ping\"\n              style={{ animationDelay: \"0.2s\" }}\n            ></div>\n          </div>\n        </div>\n      </button>\n\n      {/* Chat Interface Modal */}\n      {isOpen && (\n        <ChatInterface product={product} onClose={() => setIsOpen(false)} />\n      )}\n    </>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAHA;;;;AAkBO,SAAS,YAAY,EAAE,OAAO,EAAoB;IACvD,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,iNAAQ,EAAC;IAErC,qBACE;;0BAEE,8OAAC;gBACC,SAAS,IAAM,UAAU;gBACzB,WAAU;gBACV,cAAW;gBACX,OAAM;0BAGN,cAAA,8OAAC;oBAAI,WAAU;;sCACb,8OAAC;4BACC,WAAU;4BACV,MAAK;4BACL,QAAO;4BACP,SAAQ;sCAER,cAAA,8OAAC;gCACC,eAAc;gCACd,gBAAe;gCACf,aAAa;gCACb,GAAE;;;;;;;;;;;sCAIN,8OAAC;4BAAI,WAAU;;8CACb,8OAAC;oCAAI,WAAU;;;;;;8CACf,8OAAC;oCACC,WAAU;oCACV,OAAO;wCAAE,gBAAgB;oCAAO;;;;;;;;;;;;;;;;;;;;;;;YAOvC,wBACC,8OAAC,6IAAa;gBAAC,SAAS;gBAAS,SAAS,IAAM,UAAU;;;;;;;;AAIlE"}},
    {"offset": {"line": 2478, "column": 0}, "map": {"version":3,"sources":["file:///Users/jalbo/Desktop/dev/blog/convoAI_ecommerce/components/ProductPage.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { ProductImages } from \"./ProductImages\";\nimport { ProductReviews } from \"./ProductReviews\";\nimport { AIAssistant } from \"./AIAssistant\";\n\nconst fetchProduct = async () => {\n  const res = await fetch(\"/api/product\");\n  return res.json();\n};\n\nexport function ProductPage() {\n  const [product, setProduct] = useState<any>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<any>(null);\n\n  useEffect(() => {\n    fetchProduct()\n      .then((data) => {\n        setProduct(data);\n        setIsLoading(false);\n      })\n      .catch((err) => {\n        setError(err);\n        setIsLoading(false);\n      });\n  }, []);\n\n  if (isLoading) {\n    return (\n      <div className=\"flex justify-center items-center h-screen\">\n        <div className=\"text-xl text-gray-600\">Loading product...</div>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"flex justify-center items-center h-screen\">\n        <div className=\"text-xl text-red-600\">Error loading product</div>\n      </div>\n    );\n  }\n\n  if (!product) return null;\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\">\n        {/* Product Header */}\n        <div className=\"bg-white rounded-lg shadow-sm p-6 mb-6\">\n          <h1 className=\"text-3xl font-bold text-gray-900 mb-2\">\n            {product.name}\n          </h1>\n          <div className=\"flex items-center gap-4 mb-4\">\n            <div className=\"flex items-center\">\n              <span className=\"text-yellow-400 text-2xl\">\n                {\"★\".repeat(Math.floor(product.rating))}\n                {\"☆\".repeat(5 - Math.floor(product.rating))}\n              </span>\n              <span className=\"ml-2 text-gray-600 font-medium\">\n                {product.rating}\n              </span>\n              <span className=\"ml-1 text-gray-500\">\n                ({product.reviewCount.toLocaleString()} reviews)\n              </span>\n            </div>\n            {product.inStock && (\n              <span className=\"px-3 py-1 bg-green-100 text-green-800 rounded-full text-sm font-medium\">\n                In Stock\n              </span>\n            )}\n          </div>\n          <div className=\"flex items-baseline gap-3 mb-6\">\n            <span className=\"text-4xl font-bold text-gray-900\">\n              ${product.price}\n            </span>\n            <span className=\"text-2xl text-gray-400 line-through\">\n              ${product.originalPrice}\n            </span>\n            <span className=\"px-2 py-1 bg-red-100 text-red-800 rounded text-sm font-medium\">\n              Save {product.discount}%\n            </span>\n          </div>\n        </div>\n\n        <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-8\">\n          {/* Product Images */}\n          <ProductImages images={product.images} />\n\n          {/* Product Details */}\n          <div className=\"bg-white rounded-lg shadow-sm p-6\">\n            <h2 className=\"text-2xl font-semibold mb-4\">Product Details</h2>\n            <p className=\"text-gray-700 mb-6 leading-relaxed\">\n              {product.description}\n            </p>\n\n            <h3 className=\"text-xl font-semibold mb-3\">Specifications</h3>\n            <dl className=\"space-y-2\">\n              {Object.entries(product.specifications).map(([key, value]) => (\n                <div key={key} className=\"flex\">\n                  <dt className=\"font-medium text-gray-700 w-48\">{key}:</dt>\n                  <dd className=\"text-gray-600\">{value as string}</dd>\n                </div>\n              ))}\n            </dl>\n\n            <button className=\"mt-8 w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition shadow-md hover:shadow-lg\">\n              Add to Cart\n            </button>\n          </div>\n        </div>\n\n        {/* Reviews Section */}\n        <ProductReviews reviews={product.reviews} rating={product.rating} />\n\n        {/* AI Assistant */}\n        <AIAssistant product={product} />\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AALA;;;;;;AAOA,MAAM,eAAe;IACnB,MAAM,MAAM,MAAM,MAAM;IACxB,OAAO,IAAI,IAAI;AACjB;AAEO,SAAS;IACd,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,iNAAQ,EAAM;IAC5C,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,iNAAQ,EAAC;IAC3C,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,iNAAQ,EAAM;IAExC,IAAA,kNAAS,EAAC;QACR,eACG,IAAI,CAAC,CAAC;YACL,WAAW;YACX,aAAa;QACf,GACC,KAAK,CAAC,CAAC;YACN,SAAS;YACT,aAAa;QACf;IACJ,GAAG,EAAE;IAEL,IAAI,WAAW;QACb,qBACE,8OAAC;YAAI,WAAU;sBACb,cAAA,8OAAC;gBAAI,WAAU;0BAAwB;;;;;;;;;;;IAG7C;IAEA,IAAI,OAAO;QACT,qBACE,8OAAC;YAAI,WAAU;sBACb,cAAA,8OAAC;gBAAI,WAAU;0BAAuB;;;;;;;;;;;IAG5C;IAEA,IAAI,CAAC,SAAS,OAAO;IAErB,qBACE,8OAAC;QAAI,WAAU;kBACb,cAAA,8OAAC;YAAI,WAAU;;8BAEb,8OAAC;oBAAI,WAAU;;sCACb,8OAAC;4BAAG,WAAU;sCACX,QAAQ,IAAI;;;;;;sCAEf,8OAAC;4BAAI,WAAU;;8CACb,8OAAC;oCAAI,WAAU;;sDACb,8OAAC;4CAAK,WAAU;;gDACb,IAAI,MAAM,CAAC,KAAK,KAAK,CAAC,QAAQ,MAAM;gDACpC,IAAI,MAAM,CAAC,IAAI,KAAK,KAAK,CAAC,QAAQ,MAAM;;;;;;;sDAE3C,8OAAC;4CAAK,WAAU;sDACb,QAAQ,MAAM;;;;;;sDAEjB,8OAAC;4CAAK,WAAU;;gDAAqB;gDACjC,QAAQ,WAAW,CAAC,cAAc;gDAAG;;;;;;;;;;;;;gCAG1C,QAAQ,OAAO,kBACd,8OAAC;oCAAK,WAAU;8CAAyE;;;;;;;;;;;;sCAK7F,8OAAC;4BAAI,WAAU;;8CACb,8OAAC;oCAAK,WAAU;;wCAAmC;wCAC/C,QAAQ,KAAK;;;;;;;8CAEjB,8OAAC;oCAAK,WAAU;;wCAAsC;wCAClD,QAAQ,aAAa;;;;;;;8CAEzB,8OAAC;oCAAK,WAAU;;wCAAgE;wCACxE,QAAQ,QAAQ;wCAAC;;;;;;;;;;;;;;;;;;;8BAK7B,8OAAC;oBAAI,WAAU;;sCAEb,8OAAC,6IAAa;4BAAC,QAAQ,QAAQ,MAAM;;;;;;sCAGrC,8OAAC;4BAAI,WAAU;;8CACb,8OAAC;oCAAG,WAAU;8CAA8B;;;;;;8CAC5C,8OAAC;oCAAE,WAAU;8CACV,QAAQ,WAAW;;;;;;8CAGtB,8OAAC;oCAAG,WAAU;8CAA6B;;;;;;8CAC3C,8OAAC;oCAAG,WAAU;8CACX,OAAO,OAAO,CAAC,QAAQ,cAAc,EAAE,GAAG,CAAC,CAAC,CAAC,KAAK,MAAM,iBACvD,8OAAC;4CAAc,WAAU;;8DACvB,8OAAC;oDAAG,WAAU;;wDAAkC;wDAAI;;;;;;;8DACpD,8OAAC;oDAAG,WAAU;8DAAiB;;;;;;;2CAFvB;;;;;;;;;;8CAOd,8OAAC;oCAAO,WAAU;8CAA+H;;;;;;;;;;;;;;;;;;8BAOrJ,8OAAC,+IAAc;oBAAC,SAAS,QAAQ,OAAO;oBAAE,QAAQ,QAAQ,MAAM;;;;;;8BAGhE,8OAAC,yIAAW;oBAAC,SAAS;;;;;;;;;;;;;;;;;AAI9B"}}]
}